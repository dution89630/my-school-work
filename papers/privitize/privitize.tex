
% ============================================================================
% ============================================================================
\documentclass[11pt]{article}
\usepackage{epic,eepic,amsmath,latexsym,fullpage,amssymb,color}
\usepackage{ifthen,graphics,epsfig}
\usepackage[english]{babel}
\usepackage{times}
\usepackage{ulem}


\bibliographystyle{plain}


\begin{document}
%-----------------------for square--------------------------------------------
\newlength {\squarewidth}
\renewenvironment {square}
{
\setlength {\squarewidth} {\linewidth}
\addtolength {\squarewidth} {-12pt}
\renewcommand{\baselinestretch}{0.75} \footnotesize
\begin {center}
\begin {tabular} {|c|} \hline
\begin {minipage} {\squarewidth}
\medskip
}{
\end {minipage}
\\ \hline
\end{tabular}
\end{center}
}  
 
%--------------------------------------------------------------------
%--------------------------------------------------------------------
%-------- macros for algorithm ---------------------------------------
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Theorem~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofL}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Lemma~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofC}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Corollary~\ref{\toto}}$\par\vspace{3mm}}


\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 
9\else 0\fi \arabic{linecounter}}



% ----------------------for appendix --------------------------------------
\newenvironment{lemma-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Lemma~\ref{#1} }]}%
{\end{trivlist}}

\newenvironment{theorem-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Theorem~\ref{#1} }]}%
{\end{trivlist}}

\newenvironment{corollary-repeat}[1]{\begin{trivlist}
\item[\hspace{\labelsep}{\bf\noindent Corollary~\ref{#1} }]}%
{\end{trivlist}}

%==================================================================

% =========================================================================
\newcommand{\Xomit}[1]{}
%==========================================================================

\title{Adding non-blocking strong isolation to a locking STM (In this case TL2)}
\maketitle

\section{Protocol}
I think people overwhelmingly agree that privatization safety in TM is a good thing.

In addition it has been argued that strong atomicity should be required for concurrent memory accesses inside and outside of transactions.
One argument is that without it, things can get complicated for the programmer.

It has also been argued that strong isolation is a bad thing.
One of the main arguments against this is that it is too expensive.

There have been protocols proposed that implement strong atomicity, but they all require using locks
and create some memory barriers
(although I guess there are some hardware transactional memory supports strong isolation by default).
These barriers occur when a programmer reads or writes to a shared variable outside of a transaction.
The problem with this is that the programmer thinks he is just preforming basic reads and writes and using
but what really is going on is a blocking solution that uses locks.
It would be better to preform these operations without blocking using as little mechanisms as possible.

What is proposed here is a way to preform the shared reads and writes that occur outside of a transaction
without blocking.
In order to do this, atomic reads and writes are used, as well as possibly a compare and swap in the case
of a conflict with a committing transaction.

The STM protocol itself uses locks and I tried to model it after TL2.


\section{Basic Idea}
The idea is to take a word based STM algorithm that uses locks (in this case TL2) and add non-blocking strong isolation.

Assume that we want strong isolation in an STM.  Then why should it be non-blocking?
When a programmer choses to use an STM he should expect that the STM system will use some sort of synchronization methods to ensure
transactions are atomic.
Of course because of this he can expect to make some compromises, for example he might expect the transactions to be blocking, so
if a thread running a transaction gets descheduled, then the progress of other threads might be stopped until the thread is rescheduled.
Or in order to ensure atomicity transactions might be slower to execute then normal code (i.e. because of aborts among other things).
Or even if a thread running a live transaction crashes, it might block the progress of other transactions.

Now what about for accesses to shared memory outside of transactions?
Should he expect the same problems here?
Here we have a word based STM system.
So the read/write operations to shared memory done outside of the transactions are single load/store operations.
Without the STM each of these would be just a (single low level?) atomic operation.
But when using an STM these operations become blocking, so they have the same progress guarantees as the transactions.
Should the programmer expect that a single atomic load/store might block forever?
What I try to propose here is a way to implement non-blocking strong isolation in TL2 hopefully without doing anything too costly.

\section{Strong Isolation}
The protocol proposed here tries to implement strong isolation in the sense that transactions and non-transactional accesses are
linearizable in the same history.

\section{Description}

\subsection{Memory Setup}
To the programmer the structure of the memory is a normal set of addresses.
To the system, instead of each address corresponding to one location in memory, it corresponds to two.
One area is called the $NT$ area and one the $T$ area.
Only the non-transactional access modify the $NT$ area, and only transactional accesses modify the $T$ area.
When a programmer calls ${\sf transactional\_read}()$ or ${\sf non\_transactional\_read}()$ the value returned could come from either
of the two areas depending on the state of the system.

Each memory word in the $NT$ area points to a shared structure.
This structure contains the following values:
$addr$ which is the location of this value in memory.
$value$ which is the value the programmer passed to some ${\sf non\_transactional\_write}()$ operation.
$id$ a unique id of the thread that created this structure.
$local\_time$ the local time value of the thread when it created this structure.
$time$ the approximate global clock time when the thread created this structure.

Each memory word in the $T$ area points to a shared structure.
This structure contains the following values:
$addr$ which is the location of this value in memory.
$status$ pointer to memory that contains the status $(\mathit{LIVE}, \mathit{ABORTED}, \mathit{COMMITTED})$ of the transaction that wrote this location.
$value$ which is the value the programmer passed to some ${\sf non\_transactional\_write}()$ operation.
$time$ the global clock time associated with this transaction.
$last$ pointer to the most recent $NT$ structure seen by this transaction.
$prev$ pointer to the $T$ data structure that was at $addr$ before this one was added.

See figure \ref{fig:mem} for a example memory structure.

\begin{figure}[t]
	\begin{center}
	\includegraphics[scale=0.55]{./mem-fig.pdf}
	\caption{Structure of the memory\label{fig:mem}}
	\end{center}
\end{figure}


\subsection{Operations Descriptions}

{\bf ${\sf non\_transactional\_read}()$}
Find the most recent value from $T$ and $NT$ memory.
If there is a live transaction in the commit process it might have to be aborted to ensure safety.
Update the local value $time$ to the most recent.

{\bf ${\sf non\_transactional\_write}()$}
Create a new structure in shared memory, initialize the values, add to write set.


{\bf ${\sf transaction\_begin}()$}
Initialize the transactions.
Like in TL2, read only transactions do not need to keep a read set.
The variable $rv$ is set to the global clock time.
This is used for validation.

{\bf ${\sf transactional\_read}()$}
Find the most recent value from $T$ and $NT$ memory.
If it is too recent, then abort.
Add it to the read set if this is a writing transaction.
Note that there are two read sets.
One is for reads done from $T$ memory, the other is for reads done from $NT$ memory.
The reason for having two read sets is because they have different validations.

Sometimes a transaction might abort due to non-transactional writes.
A non-transactional write does not increase the global counter, but a transaction does validation based on the
global counter value it read.
This means that a read-only transaction might abort forever because it always reads a clock time that is old.
To avoid this, when a transaction aborts because it read an NT value, the ${\sf transactional\_read}()$ operation
will increment the global counter if the value it read has a greater clock value.

{\bf ${\sf transactional\_write}()$}
Create a new structure in shared memory, initialize the values, add it to the $ws$.

{\bf ${\sf try\_to\_commit}()$}
Return committed if it is a read only transaction.

First lock all the items in the write set.
Get a new time from the global clock.
Setup the write locations and update $T$ memory to point to them.
Validate the read set.
For each item in the $T$ and $NT$ read set, make sure the location you read has not been updated.

\section{TODO}
\subsection{Other Algorithms}
TL2 is probably the most popular STM algorithm.
What about non-blocking STM algorithms, how can strong isolation be added to those?

\subsection{Optimizations}
I ``tried'' to keep the algorithm as simple as possible.
There should be ways to optimize the operations.
For example the $time$ might be useful in some operations
in order to avoid some of the checks.


Should move the validation to before the items are stored to shared memory in the try to commit!!!!!

Also can some of the pointers be removed?
Less indirection?

\subsection{Privitization}
If the algorithm is correct then it already is privatization safe.
But, there could be optimizations done for privatization.
Consider that we know which transactions privatize memory locations (for example, user defined, complier defined).
Once the location is privatized and the last transaction to write to the location
is committed or aborted (this can be found by looking at ${\sf load}(addr, T).status$)
then the location is private and the checks can be avoided.

\subsection{Fixes}
Probably lots.

Some $NT$ locations are compared by using memory addresses, instead they should use the $local\_time$ and $id$ for comparison.

The freeing of locations is either done incorrectly, or not done at all.

\section{Algorithm}
The first version pesudo-code follows.

%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


{\bf procedure} ${\sf load}(addr, place)$; \\
\line{DA01} \> {\bf if} $(place = \mathit{T})$ {\bf then} ${\sf return} \downarrow addr$ {\bf end if} \\
\line{DA01} \> ${\sf return} \downarrow (addr + \mathit{MEM\_SIZE})$. \\

{\bf procedure} ${\sf store}(addr, value, place)$; \\
\line{DA01} \> {\bf if} $(place = \mathit{T})$ {\bf then} $\downarrow addr \gets value$ {\bf end if} \\
\line{DA01} \> $\downarrow (addr + \mathit{MEM\_SIZE}) \gets value$. \\


\end{tabbing}
\normalsize
\end{minipage}
}
\caption{load/store procedures, note that these are just helper function}
\label{fig-prevent-looping}
}
\end{figure}
%=================================================================


%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


{\bf operation}  ${\sf non\_transactional\_read}(addr)$;\\
\line{DA01} \> $tmp \gets {\sf load}(addr, T)$; \\
\line{DA01} \> {\bf while} $(tmp.status \neq \mathit{COMMITTED})${\bf do} \\
\line{DA01} \>\> {\bf if} $(tmp.time \leq time \wedge tmp.status = \mathit{LIVE})$ {\bf then} \\
\line{DA01} \>\>\> ${\sf \mathit{C\&S}}(tmp.status, \mathit{LIVE}, \mathit{ABORTED})$; \\
\line{DA01} \>\> {\bf else} \\
\line{DA01} \>\>\> $tmp \gets tmp.prev$; \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \> {\bf end while} \\
\line{DA01} \> $tmp2 \gets load(addr, NT)$; \\

\line{DA01} \> {\bf if} $(tmp.last \neq tmp2)$ {\bf then} $tmp \gets tmp2$; \\
\line{DA01} \>\> $time \gets {\sf max}(time, tmp.time + 0.1, tmp2.time + 0.1)$; \\
\line{DA01} \>\> {\bf else} $time \gets {\sf max}(time, tmp.time, tmp2.time + 0.1)$; \\
\line{DA01} \> {\bf end if} \\
\line{DA01} \> {\sf return} $tmp.val$. \\

{\bf operation}  ${\sf non\_transactional\_write}(addr, value)$;\\
\line{DA01} \> allocate new variable $next\_write$ \\
\line{DA01} \> $time \gets {\sf max}(time, \mathit{GLOBAL\_CLOCK})$; \\
\line{DA01} \> $next\_write.addr \gets addr$; \\
\line{DA01} \> $next\_write.value \gets value$; \\
\line{DA01} \> $next\_write.time \gets time$; \\
\line{DA01} \> $next\_write.local\_time \gets local\_time++$; \\
\line{DA01} \> $next\_write.id \gets id$; \\
\line{DA01} \> ${\sf store}(addr, next\_write, NT)$; \\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Non-transactional operations}
\label{fig-prevent-looping}
}
\end{figure}
%=================================================================


%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


%{\bf procedure} ${\sf validate\_ntrs}()$; \\
%\line{DA01} \> {\bf for each} $item$ in $ntrs$ {\bf do} \\
%\line{DA01} \>\> $tmp \gets load(item.addr, \mathit{NT})$; \\
%\line{DA01} \>\> {\bf if} $tmp.id \neq item.id$ {\bf then} ${\sf abort}()$; \\
%\line{DA01} \>\> {\bf else if} $tmp.local\_time \neq item.local\_time$ {\bf then} ${\sf abort}()$ {\bf end if} \\
%\line{DA01} \> {\bf end for} \\

{\bf procedure} ${\sf validate\_all}()$; \\
\line{DA01} \> {\bf for each} $item$ in $rs$ {\bf do} \\
\line{DA01} \>\> {\bf if} $item.addr$ is locked by someone else {\bf then} ${\sf return}(0)$ {\bf end if} \\
\line{DA01} \>\> $tmp \gets load(item.addr, \mathit{T})$; \\
\line{DA01} \>\> {\bf while} $tmp.status \neq \mathit{COMMITTED}$ {\bf do} \\
\line{DA01} \>\>\> $tmp \gets tmp.prev$; \\
\line{DA01} \>\> {\bf end while} \\
\line{DA01} \>\> $tmp2 \gets load(item.addr, \mathit{NT})$; \\
\line{DA01} \>\> {\bf if} $(tmp.last \neq tmp2)$ {\bf then} ${\sf return}(0)$; \\
\line{DA01} \>\> {\bf else if} $tmp.time > rv$ {\bf then} ${\sf return}(0)$; \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \> {\bf for each} $item$ in $ntrs$ {\bf do} \\
\line{DA01} \>\> {\bf if} $item.addr$ is locked {\bf then} ${\sf return}(0)$ {\bf end if} \\
\line{DA01} \>\> {\bf if} $(load(item.addr, \mathit{T}).time > rv)$ {\bf then} ${\sf return}(0)$ {\bf end if} \\
\line{DA01} \>\> $tmp \gets load(item.addr, \mathit{NT})$; \\
\line{DA01} \>\> {\bf if} $tmp.id \neq item.id$ {\bf then} ${\sf return}(0)$; \\
\line{DA01} \>\> {\bf else if} $tmp.local\_time \neq item.local\_time$ {\bf then} ${\sf return}(0)$ {\bf end if} \\
\line{DA01} \> {\bf end for} \\
\line{DA01} \> ${\sf return}(1)$. \\


{\bf procedure} ${\sf abort}()$; \\
\line{DA01} \> free items in $ws$, $rs$, and $ntrs$ \\
\line{DA01} \> jump to line \ref{START1}. \\

{\bf procedure} ${\sf abort\_keep\_rv}()$; \\
\line{DA01} \> free items in $ws$, $rs$, and $ntrs$ \\
\line{DA01} \> jump to line \ref{START2}. \\



\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transactional helper procedures}
\label{fig-prevent-looping}
}
\end{figure}
%=================================================================




%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


{\bf operation}  ${\sf transactional\_read}(addr)$;\\
\line{DA01} \> {\bf if} $addr \in ws$ {\bf then} \\
\line{DA01} \>\> return the $value$ of the $item$ with $addr$ in $ws$ \\
\line{DA01} \> {\bf end if} \\

\line{DA01} \> $tmp \gets {\sf load}(addr, \mathit{T})$; \\


\line{DA01} \> {\bf while} $(tmp.status \neq \mathit{COMMITTED})$ {\bf do} \\
\line{DA01} \>\> {\bf if} $addr$ is locked {\bf then} \\
\line{DA01} \>\>\> ${\sf abort}()$; \\
\line{DA01} \>\> {\bf else} \\
\line{DA01} \>\>\> $tmp \gets tmp.last$; \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \> {\bf end while} \\
\line{DA01} \> $tmp2 \gets load(addr, NT)$; \\
\line{DA01} \> {\bf if} $(tmp.last \neq tmp2)$ {\bf then}  \\
\line{DA01} \>\> {\bf if} $({\sf max}(tmp.time + 0.1, tmp2.time + 0.1) > rv)$ {\bf then} \\
\line{DA01} \>\>\> $rv \gets \mathit{GLOBAL\_CLOCK}$; \\
\line{DA01} \>\>\> {\bf if} $({\sf max}(tmp.time + 0.1, tmp2.time + 0.1) > rv)$ {\bf then} \\
\> \% Increment clock to ensure progress in case of abort by NT write \\
\line{DA01} \>\>\>\> $rv \gets {\sf incrament\&fetch}(\mathit{GLOBAL\_CLOCK})$; \\
\line{DA01} \>\>\> {\bf end if} \\
\line{DA01} \>\>\> ${\sf abort\_keep\_rv}()$; \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \>\> {\bf if} $write\_transaction$ {\bf then} \\
\line{DA01} \>\>\> add $tmp2$ to $ntrs$ \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \>\> {\sf return} $tmp2.val$; \\

\line{DA01} \> {\bf end if} \\

\line{DA01} \> {\bf if} $(tmp.time > rv)$ {\bf then} ${\sf abort}()$ {\bf end if} \\
\line{DA01} \> {\bf if} $write\_transaction$ {\bf then} \\
\line{DA01} \>\> add $tmp$ to $rs$ \\
\line{DA01} \> {\bf end if} \\
\line{DA01} \> {\sf return} $tmp.val$. \\


{\bf operation}  ${\sf transactional\_write}(addr, value)$;\\
\line{DA01} \> {\bf if} $addr \not\in ws$ {\bf then} \\
\line{DA01} \>\> allocate a new variable $item$ \\
\line{DA01} \>\> $item.addr \gets addr$; \\
\line{DA01} \>\> $item.value \gets value$; \\
\line{DA01} \>\> $item.status \gets status$; \\
\line{DA01} \>\> $ws \gets ws \cup item$; \\
\line{DA01} \> {\bf else} \\
\line{DA01} \>\> set $item.value$ with $addr$ in $ws$ to $value$ \\
\line{DA01} \> {\bf end if} \\



\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transaction read/write}
\label{fig-prevent-looping}
}
\end{figure}
%=================================================================



%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\



{\bf operation}  ${\sf begin\_transaction}()$;\\
\line{DA01} \> set $write\_transaction$ based on complier/user input \\
\line{START1} \> $rv \gets \mathit{GLOBAL\_CLOCK}$; \\
\line{START2} \> Allocate new variable $status$ \\
\line{DA01} \> $status \gets \mathit{LIVE}$; \\
\line{DA01} \> $ws \gets \emptyset$; $rs \gets \emptyset$; $ntrs \gets \emptyset$; \\
\line{DA01} \> more??. \\

{\bf operation}  ${\sf try\_to\_commit}()$;\\
\line{DA01} \> {\bf if} $(ws = \emptyset)$ {\bf then} ${\sf return}(\mathit{COMMITTED})$ {\bf end if} \\
\line{DA01} \> Acquire locks for items in $ws$ \\
\line{DA01} \> $time \gets {\sf fetch\&inc}(\mathit{GLOBAL\_CLOCK})$; \\
\line{DA01} \> {\bf for each} $(item \in ws)$ {\bf do} \\
\line{DA01} \>\> $item.last \gets load(item.addr, NT)$; \\
\line{DA01} \>\> $item.time \gets time$; \\
\line{DA01} \>\> $item.prev \gets load(item.addr, T)$; \\
\line{DA01} \>\> $store(item.addr, item, T)$; \\
\line{DA01} \> {\bf end for} \\
\line{DA01} \> {\bf if} $\neg{\sf validate\_all}()$ {\bf then} \\
\line{DA01} \>\> ${\sf \mathit{C\&S}}(status, \mathit{LIVE}, \mathit{ABORTED})$; \\
\line{DA01} \>\> release locks and ${\sf abort}()$; \\
\line{DA01} \> {\bf end if} \\
\> \% Ensure the writes haven't been overwritten by $NT$ writes \\
\line{DA01} \> {\bf for each} $(item \in ws \backslash ws \cap rs)$ {\bf do} \\
\line{DA01} \>\> {\bf if} $(item.last \neq load(item.addr, NT))$ {\bf then} \\
\line{DA01} \>\>\> ${\sf \mathit{C\&S}}(status, \mathit{LIVE}, \mathit{ABORTED})$; \\
\line{DA01} \>\>\> release locks and ${\sf abort}()$; \\
\line{DA01} \>\> {\bf end if} \\
\line{DA01} \> {\bf end for} \\
\line{DA01} \> ${\sf \mathit{C\&S}}(status, \mathit{LIVE}, \mathit{COMMITTED})$; \\
\line{DA01} \> {\bf if} $(status \neq \mathit{COMMITTED})$ {\bf then} \\
\line{DA01} \>\> release locks and ${\sf abort}()$; \\
\line{DA01} \> {\bf end if} \\
\line{DA01} \> Release locks \\
\line{DA01} \> ${\sf return}(\mathit{COMMITTED})$. \\


\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transaction begin/commit}
\label{fig-prevent-looping}
}
\end{figure}
%=================================================================



%=========================================================================
%========================================================================
\end{document}
%========================================================================
%========================================================================