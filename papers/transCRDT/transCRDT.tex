


% ============================================================================
\documentclass[11pt,letterpaper]{article}
%\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage{epic,eepic,amsmath,latexsym,amssymb,color,amsthm}
\usepackage{ifthen,graphics,epsfig,fullpage} 
\usepackage[english]{babel} 
\bibliographystyle{plain}
\usepackage{times}


% =========================================================================
\newcommand{\Xomit}[1]{}
\newcommand{\ignore}[1]{}
% =========================================================================


\begin{document}

%-----------------------for square--------------------------------------------
\newlength {\squarewidth}
\renewenvironment {square}
{
\setlength {\squarewidth} {\linewidth}
\addtolength {\squarewidth} {-12pt}
\renewcommand{\baselinestretch}{0.75} \footnotesize
\begin {center}
\begin {tabular} {|c|} \hline
\begin {minipage} {\squarewidth}
\medskip
}{
\end {minipage}
\\ \hline
\end{tabular}
\end{center}
}  
 
%--------------------------------------------------------------------
%--------------------------------------------------------------------
%-------- macros for algorithm ---------------------------------------
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Theorem~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofL}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Lemma~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofC}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Corollary~\ref{\toto}}$\par\vspace{3mm}}


\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 
9\else 0\fi \arabic{linecounter}}

\newcommand{\tuple}[1]{\ensuremath{\left \langle #1 \right \rangle }}

%----------------------------------------------------------------------

Originally proposed as a hardware mechanism for easily developing non-blocking data structures,
Transactional Memory (TM) has since evloved to become a general pourpose method for easily writing
efficient concurrent code.
With TM a programmer is able to declare atomic transacions, more specifically, blocks
one or several reads and writes to shared memory bounded by calls to the
$\mathit{begin\_transaction}$ and $\mathit{end\_transaction}$ operations, with
these reads and writes appearing to have executed in exclusion with no interleaving
between other transactions, as if a single global lock had been used.

Unlike using a global lock, several transactions can be executed at the same time,
with the system ensuring that they appear to have executed in exclusion.
In order to still ensure this, the TM system will keep track of reads and writes
performed by transactions, detecting conflicts, and aborting and restarting transactions
as necessary.
Defining precisely how transactions execute in relation to eachother is a consistency criterion.
Probably the most commonly used criterion, linearizability, roughly says that each
operation appears to have occured at some instant in time between its invocation and completion.
Opacity, the most common criterion used for TM, ensures this for both aborted and committed transactions.

While for certain applications, certain STM systems exhibit performance that scales as the number
of processing core increases, many applications 

\section{Stop the world}

The most direct way to implemnt the STM system is to allow all processes
execute concurrently in isolation without making any modifications to shared memory.
A single copy of the data structure is store in shared memory that is not modified.
By avoiding modifications to this data structure, any group of reads to this data
performed during a transaction will be guaranteed to provide a consistent snapshot.
Updates done by transactions are stored locally.

Eventually these updates must be shared so that they become visible to the other processes.
This is done in a simple ``stop the world'' fashion.
A separate process will tell every process to complete their current transaction (if there is one) and then to pause
their execution.
Once all processes are stopped, the separate process will go through all the updates that are stored locally at
each process and, using the communitive properties of the CRDT? model, will merge them to the shared copy.
Updates done by each process are considered ``concurrent'' with the updates of all other processes and are merged
accordinly, for example by using the add wins model of a concurrent set.

Ocnce all updates have been merged to the shared copy, the processes are allowd to continue their execution,
with transactions reading from the new version of the data.

\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\



{\bf operation} ${\sf begin\_transaction}()$ \\
\line{A01} \> {\bf while} ($\sf{true}$) {\bf do} \\
\line{A01} \>\> $\mathit{stopped} \gets {\sf false}$ \\
\line{A01} \>\> {\bf if} ($\neg \mathit{stop}$) {\bf then} \\
\line{A01} \>\>\> $\mathit{live} \gets {\sf false}$ \\
\line{A01} \>\>\> $\sf return$() \\
\line{A01} \>\> {\bf else} \\
\line{A01} \>\>\> $\mathit{live} \gets \mathit{false}$ \\
\line{A01} \>\>\> $\mathit{stopped} \gets \mathit{true}$ \\
\line{A01} \>\>\> ${\sf wait}(\mathit{stop})$ \\
\line{A01} \> {\bf end if} {\bf end while} \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_read}(\mathit{addr})$ \\
\line{A01} \> {\bf if}($\mathit{addr} \in \mathit{WS}$) {\bf then} \\
\line{A01} \>\> ${\sf return}$ ($\mathit{WS.get}(\mathit{addr})$) {\bf end if} \\
\line{A01} \> ${\sf return}$($\mathit{hash\_table.get}(\mathit{addr})$) \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_update}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
\line{A01} \> $\mathit{WS.add}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf commit}()$ \\
\line{A01} \> $\mathit{live} \gets {\sf false}$ \\
\line{A01} \> $\mathit{stopped} \gets {\sf true}$ \\
\line{A01} \> ${\sf return}$ (${\sf true}$) \\
{\bf end operation}. \\
\\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transactional operations for the stop-the-world version}
\label{fig:ntops}
}
\end{figure}



\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\

{\bf operation} ${\sf stop\_the\_world}()$ {\bf is} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> $\mathit{p.stop} \gets {\sf true}$ \\
\line{A01} \>\> {\bf while}($\neg \mathit{p.stopped} \cup \mathit{p.live}$); \\
\line{A01} \> {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> {\bf for each} ($\mathit{item} \in \mathit{p.WS}$) {\bf do} \\
\line{A01} \>\>\> $\mathit{hash\_table.merge}(\mathit{item.addr}, \mathit{item.op}, \mathit{item.var})$ \\
\line{A01} \>\> {\bf end for} \\
\line{A01} \>\> $\mathit{p.WS.clear}()$ {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> $\mathit{p.stopped} \gets {\sf false}$; $\mathit{p.stop} \gets {\sf false}$ \\
{\bf end operation}. \\
\\


\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Operation to stop the world and merge the updates}
\label{fig:ntops}
}
\end{figure}


\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


{\bf operation} ${\sf begin\_transaction}()$ \\
\line{A01} \> {\bf if} ($\mathit{WS.is\_empty}()$) {\bf then} \\
\line{A01} \>\> $\mathit{start\_time} \gets \mathit{GC}$ {\bf end if} \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_read}(\mathit{addr})$ \\
\line{A01} \> {\bf if}($\mathit{addr} \in \mathit{WS}$) {\bf then} \\
\line{A01} \>\> ${\sf return}$ ($\mathit{WS.get}(\mathit{addr})$) {\bf end if} \\
\line{A01} \> ${\sf return}$($\mathit{multi\_version\_struct.get}(\mathit{addr})$) \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_update}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
\line{A01} \> $\mathit{WS.add}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf commit}()$ \\

\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> ${\sf lock}(\mathit{item.addr})$ {\bf end for} \\
\line{A01} \> $\mathit{time} \gets {\sf incrament\&fetch}(\mathit{GC})$ \\
\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> $\mathit{multi\_version\_array.merge}(\mathit{item.addr}, \mathit{item.op}, \mathit{item.val})$ {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> ${\sf unlock}(\mathit{item.addr})$ {\bf end for} \\
\line{A01} \> $\mathit{WS.clear}()$ \\
\line{A01} \> ${\sf return}$ (${\sf false}$) \\
{\bf end operation}. \\
\\



\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transactional operations for the more traditional STM version}
\label{fig:ntops}
}
\end{figure}




\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\




{\bf operation}  ${\sf get}(\mathit{addr}, \mathit{time})$ {\bf is}\\
\line{A01} \> $\mathit{next} \gets \mathit{hash\_table.get}(\mathit{addr})$ \\
\line{A01} \> {\bf while}($\mathit{time} < \mathit{next.time}$){\bf do} \\
\line{A01} \>\> $\mathit{next} \gets \mathit{next.time}$ {\bf end while} \\
\line{A01} \> ${\sf return}(\mathit{next.val})$ \\
{\bf end operation}. \\
\\


\line{A01} \> $\mathit{tmp} \gets {\sf load}(\mathit{addr})$; \\ 




\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Operations of the mulit-version structure}
\label{fig:ntops}
}
\end{figure}




\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\




{\bf operation}  ${\sf non\_transactional\_read}(\mathit{addr})$ {\bf is}\\
\line{A01} \> $\mathit{tmp} \gets {\sf load}(\mathit{addr})$; \\ 
\line{A02} \> {\bf if} $( ~\mathit{tmp}$ is of type T $ \wedge \mathit{tmp.status} \neq$ COMMITTED ) \\
\line{A03}  \>\>  {\bf then if}  $(\mathit{tmp.time}  \leq \mathit{time}  \wedge  \mathit{tmp.status} = $ LIVE) \\
\line{A04} \>\>\>\> {\bf then} \=${\sf \mathit{C\&S}}$($tmp.status$, LIVE, ABORTED) {\bf end if}; \\
%\line{A05} \>\> {\bf end if} \\
\line{A06} \>\>\> {\bf if} ($tmp.status \neq $ COMMITTED)  \\
\line{A07} \>\>\>\> {\bf then} $\mathit{value} \gets \mathit{tmp.last}$ \\
\line{A08} \>\>\>\> {\bf else} $\mathit{value} \gets \mathit{tmp.value}$ \\
\line{A05} \>\>\> {\bf end if}; \\
\line{A09} \>\> {\bf else} $\mathit{value} \gets \mathit{tmp.value}$ \\
\line{A09A} \> {\bf end if}; \\
\line{A10} \> $\mathit{time} \gets {\sf max}(\mathit{time}, \mathit{tmp.time})$ \\
\line{A11} \> {\bf if} ($\mathit{time} = \infty$) {\bf then} $\mathit{time} = \mathit{GCV}$ {\bf end if}; \\
\line{A12} \> ${\sf return}$ ($\mathit{value}$) \\
{\bf end operation}. \\
\\

{\bf operation}  ${\sf contains}(\mathit{key})$ {\bf is}\\
\line{A01} \> {\bf if} $key \in \mathit{list}$ {\bf then} \\
\line{A01} \>\> ${\sf return}$ ($\sf{true}$) {\bf end if} \\
\line{A01} \> $\mathit{hash} \gets {\sf hash}(\mathit{key})$ \\


\line{A01} \> $\mathit{tmp} \gets {\sf load}(\mathit{addr})$; \\ 
\line{A02} \> {\bf if} $( ~\mathit{tmp}$ is of type T $ \wedge \mathit{tmp.status} \neq$ COMMITTED ) \\
\line{A03}  \>\>  {\bf then if}  $(\mathit{tmp.time}  \leq \mathit{time}  \wedge  \mathit{tmp.status} = $ LIVE) \\
\line{A04} \>\>\>\> {\bf then} \=${\sf \mathit{C\&S}}$($tmp.status$, LIVE, ABORTED) {\bf end if}; \\
%\line{A05} \>\> {\bf end if} \\
\line{A06} \>\>\> {\bf if} ($tmp.status \neq $ COMMITTED)  \\
\line{A07} \>\>\>\> {\bf then} $\mathit{value} \gets \mathit{tmp.last}$ \\
\line{A08} \>\>\>\> {\bf else} $\mathit{value} \gets \mathit{tmp.value}$ \\
\line{A05} \>\>\> {\bf end if}; \\
\line{A09} \>\> {\bf else} $\mathit{value} \gets \mathit{tmp.value}$ \\
\line{A09A} \> {\bf end if}; \\
\line{A10} \> $\mathit{time} \gets {\sf max}(\mathit{time}, \mathit{tmp.time})$ \\
\line{A11} \> {\bf if} ($\mathit{time} = \infty$) {\bf then} $\mathit{time} = \mathit{GCV}$ {\bf end if}; \\
\line{A12} \> ${\sf return}$ ($\mathit{value}$) \\
{\bf end operation}. \\
\\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Non-transactional operations for reading and writing a variable.}
\label{fig:ntops}
}
\end{figure}



\end{document}