


% ============================================================================
\documentclass[11pt,letterpaper]{article}
%\usepackage[T1]{fontenc}
%\usepackage[latin1]{inputenc}
\usepackage{epic,eepic,amsmath,latexsym,amssymb,color,amsthm}
\usepackage{ifthen,graphics,epsfig,fullpage} 
\usepackage[english]{babel} 
\bibliographystyle{plain}
\usepackage{times}


% =========================================================================
\newcommand{\Xomit}[1]{}
\newcommand{\ignore}[1]{}
% =========================================================================


\begin{document}

%-----------------------for square--------------------------------------------
\newlength {\squarewidth}
\renewenvironment {square}
{
\setlength {\squarewidth} {\linewidth}
\addtolength {\squarewidth} {-12pt}
\renewcommand{\baselinestretch}{0.75} \footnotesize
\begin {center}
\begin {tabular} {|c|} \hline
\begin {minipage} {\squarewidth}
\medskip
}{
\end {minipage}
\\ \hline
\end{tabular}
\end{center}
}  
 
%--------------------------------------------------------------------
%--------------------------------------------------------------------
%-------- macros for algorithm ---------------------------------------
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newcommand{\toto}{xxx}
\newenvironment{proofT}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Theorem~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofL}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Lemma~\ref{\toto}}$\par\vspace{3mm}}
\newenvironment{proofC}{\noindent{\bf
Proof }} {\hspace*{\fill}$\Box_{Corollary~\ref{\toto}}$\par\vspace{3mm}}


\newcounter{linecounter}
\newcommand{\linenumbering}{\ifthenelse{\value{linecounter}<10}
{(0\arabic{linecounter})}{(\arabic{linecounter})}}
\renewcommand{\line}[1]{\refstepcounter{linecounter}\label{#1}\linenumbering}
\newcommand{\resetline}[1]{\setcounter{linecounter}{0}#1}
\renewcommand{\thelinecounter}{\ifnum \value{linecounter} > 
9\else 0\fi \arabic{linecounter}}

\newcommand{\tuple}[1]{\ensuremath{\left \langle #1 \right \rangle }}

%----------------------------------------------------------------------

Originally proposed as a hardware mechanism for easily developing non-blocking data structures,
Transactional Memory (TM) has since evloved to become a general pourpose method for easily writing
efficient concurrent code.
With TM a programmer is able to declare atomic transacions, more specifically, blocks
one or several reads and writes to shared memory bounded by calls to the
$\mathit{begin\_transaction}$ and $\mathit{end\_transaction}$ operations, with
these reads and writes appearing to have executed in exclusion with no interleaving
between other transactions, as if a single global lock had been used.

Unlike using a global lock, several transactions can be executed at the same time,
with the system ensuring that they appear to have executed in exclusion.
In order to still ensure this, the TM system will keep track of reads and writes
performed by transactions, detecting conflicts, and aborting and restarting transactions
as necessary.
Defining precisely how transactions execute in relation to eachother is a consistency criterion.
Probably the most commonly used criterion, linearizability, roughly says that each
operation appears to have occured at some instant in time between its invocation and completion.
Opacity, the most common criterion used for TM, ensures this for both aborted and committed transactions.

While for certain applications, certain STM systems exhibit performance that scales as the number
of processing core increases, many applications 

\section{Stop the world}

The most direct way to implemnt the STM system is to allow all processes
execute concurrently in isolation without making any modifications to shared memory.
A single copy of the data structure is store in shared memory that is not modified.
By avoiding modifications to this data structure, any group of reads to this data
performed during a transaction will be guaranteed to provide a consistent snapshot.
Updates done by transactions are stored locally.

Eventually these updates must be shared so that they become visible to the other processes.
This is done in a simple ``stop the world'' fashion.
A separate process will tell every process to complete their current transaction (if there is one) and then to pause
their execution.
Once all processes are stopped, the separate process will go through all the updates that are stored locally at
each process and, using the communitive properties of the CRDT? model, will merge them to the shared copy.
Updates done by each process are considered ``concurrent'' with the updates of all other processes and are merged
accordinly, for example by using the add wins model of a concurrent set.

Ocnce all updates have been merged to the shared copy, the processes are allowd to continue their execution,
with transactions reading from the new version of the data.


\subsection{Operations and data structures}

The shared copy of the data is stored in a hash table
$\mathit{hash\_table}$ with each item in the hash-table
being stored as an object
containg a value $\mathit{val}$ and
being identified by a unique address $\mathit{addr}$.

Each process has several local variables.
The boolean status variables $\mathit{stopped}$,
$\mathit{stop}$, and $\mathit{live}$ are used to indicate
where or not the process is currently executing a transaction
or is wating for the shared merging to complete.
Additionally each process contains a write set $\mathit{WS}$
implemented as a hash table
storing all updates that have taken place on this process
since the last merge operation took place.

\paragraph{begin\_transaction}
The $\mathit{begin\_transaction}$ operation is the etrance to
a transaction as indicated by the programmer.
Its main pourpose is to announce that this thread will be executing
a transaction, so that merging to shared memory does not take place
while it is executing.
Additionally, if a merging procedure has started before this transaction
has started then the $\mathit{begin\_transaction}$ operation will
block until the merging is complete.




\paragraph{transactional\_update}
The $\mathit{transactional\_update}$ operation indicates an update operation
performed to the shared data structure during a transaction.
It takes as input an identifier $\mathit{addr}$ of the location to update,
an integer $\mathit{op}$ indicating the operation to perfrom, and a value $\mathit{val}$.
The operation simple stores the update locally in a hash table, $\mathit{WS}$.
Notice that given our weakened consistency model, these updates are not
immediately propagated to shared memory, instead
they are stored locally until the merging operation takes place.

Updates performed by a process that happen at the same location are ordered by process order and
follow the update semantics of the given operation/data structure.
Additionally, the updates are ordered after the last merging operation that occured before
the start of the transaction, and any updates performed by other processes after this merge and before
the next are considered to be concurrent with this transaction.


\paragraph{transactional\_read}
The $\mathit{transactional\_read}$ operation is a read to the shared data structure
where each of the reads that occur within a single transaction return the values from
an atomic snapshot of the shared data structure.
It takes as input an identifier $\mathit{addr}$ and returns a value $\mathit{val}$.

Defined for this protocol, the snapshot is the status of shared memory at the time that
the process returns from the from the $\mathit{begin\_transaction}$ operation.
Notice that, since the $\mathit{begin\_transaction}$ operation
sets flags blocking any merging to take place, the shared data sturcutre
will not be modified, thus any values read from this structure obviously come from
an atomic snapshot.
The operation is not quite as simple as directly reading from shared memory though,
as the process might have performed updates that have not yet been merged to shared memory
and process order must still be respected.
Thus, the read starts by checking if the value has been written by this
thread since the last merge by performing a look up in the local write set
(values written before the last merge are cleard from the write set during
the $\mathit{stop\_the\_world}$ operation).
If a value is found in the write set then it is returned as it is more recent
then the value in shared memory, respecting process order.
Otherwise, if no value is found,
the location is read from the shared data structure and that value is returned.



\paragraph{commit}
The $\mathit{commit}$ operation indicates the end of a transaction.
It simple announces that this thread is no longer executing a transaction,
so that a merging operation knows that it does not have to wait for this process
before safely executing.

It is important to notice that it makes no changes to shared memory and that the write set is not cleared,
this way the updates can be kept locally and propagated to shared memory during the next merge operation.
Additionally, futre transactions performed by this process will be ordered after this
transactions as such, they must observe the modifications made by this trasaction, even if they
have not yet been propagated to shared memory.


\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\



{\bf operation} ${\sf begin\_transaction}()$ \\
\line{A01} \> {\bf while} ($\sf{true}$) {\bf do} \\
\line{A01} \>\> $\mathit{stopped} \gets {\sf false}$ \\
\line{A01} \>\> {\bf if} ($\neg \mathit{stop}$) {\bf then} \\
\line{A01} \>\>\> $\mathit{live} \gets {\sf false}$ \\
\line{A01} \>\>\> $\sf return$() \\
\line{A01} \>\> {\bf else} \\
\line{A01} \>\>\> $\mathit{live} \gets \mathit{false}$ \\
\line{A01} \>\>\> $\mathit{stopped} \gets \mathit{true}$ \\
\line{A01} \>\>\> ${\sf wait}(\mathit{stop})$ \\
\line{A01} \> {\bf end if} {\bf end while} \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_read}(\mathit{addr})$ \\
\line{A01} \> {\bf if}($\mathit{addr} \in \mathit{WS}$) {\bf then} \\
\line{A01} \>\> ${\sf return}$ ($\mathit{WS.get}(\mathit{addr})$) {\bf end if} \\
\line{A01} \> ${\sf return}$($\mathit{hash\_table.get}(\mathit{addr})$) \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_update}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
\line{A01} \> $\mathit{WS.add}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf commit}()$ \\
\line{A01} \> $\mathit{live} \gets {\sf false}$ \\
\line{A01} \> $\mathit{stopped} \gets {\sf true}$ \\
\line{A01} \> ${\sf return}$ (${\sf true}$) \\
{\bf end operation}. \\
\\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transactional operations for the stop-the-world version}
\label{fig:ntops}
}
\end{figure}



\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\

{\bf operation} ${\sf stop\_the\_world}()$ {\bf is} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> $\mathit{p.stop} \gets {\sf true}$ \\
\line{A01} \>\> {\bf while}($\neg \mathit{p.stopped} \cup \mathit{p.live}$); \\
\line{A01} \> {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> {\bf for each} ($\mathit{item} \in \mathit{p.WS}$) {\bf do} \\
\line{A01} \>\>\> $\mathit{hash\_table.merge}(\mathit{item.addr}, \mathit{item.op}, \mathit{item.var})$ \\
\line{A01} \>\> {\bf end for} \\
\line{A01} \>\> $\mathit{p.WS.clear}()$ {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{p} \in \mathit{processes}$) {\bf do} \\
\line{A01} \>\> $\mathit{p.stopped} \gets {\sf false}$; $\mathit{p.stop} \gets {\sf false}$ \\
{\bf end operation}. \\
\\


\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Operation to stop the world and merge the updates}
\label{fig:ntops}
}
\end{figure}


\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\


{\bf operation} ${\sf begin\_transaction}()$ \\
\line{A01} \> {\bf if} ($\mathit{WS.is\_empty}()$) {\bf then} \\
\line{A01} \>\> $\mathit{start\_time} \gets \mathit{GC}$ {\bf end if} \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_read}(\mathit{addr})$ \\
\line{A01} \> {\bf if}($\mathit{addr} \in \mathit{WS}$) {\bf then} \\
\line{A01} \>\> ${\sf return}$ ($\mathit{WS.get}(\mathit{addr})$) {\bf end if} \\
\line{A01} \> ${\sf return}$($\mathit{multi\_version\_struct.get}(\mathit{addr})$) \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf transactional\_update}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
\line{A01} \> $\mathit{WS.add}(\mathit{addr}, \mathit{op}, \mathit{val})$ \\
{\bf end operation}. \\
\\

{\bf operation} ${\sf commit}()$ \\

\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> ${\sf lock}(\mathit{item.addr})$ {\bf end for} \\
\line{A01} \> $\mathit{time} \gets {\sf incrament\&fetch}(\mathit{GC})$ \\
\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> $\mathit{multi\_version\_array.merge}(\mathit{item.addr}, \mathit{item.op}, \mathit{item.val}, \mathit{start\_time}, \mathit{time})$ {\bf end for} \\
\line{A01} \> {\bf for each} ($\mathit{item} \in \mathit{WS}$) {\bf do} \\
\line{A01} \>\> ${\sf unlock}(\mathit{item.addr})$ {\bf end for} \\
\line{A01} \> $\mathit{WS.clear}()$ \\
\line{A01} \> ${\sf return}$ (${\sf false}$) \\
{\bf end operation}. \\
\\



\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Transactional operations for the more traditional STM version}
\label{fig:ntops}
}
\end{figure}




\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
%\setcounter{linecounter}{200}
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=aa\=\kill %~\\




{\bf operation}  ${\sf get}(\mathit{addr}, \mathit{time})$ {\bf is}\\
\line{A01} \> $\mathit{next} \gets \mathit{hash\_table.get}(\mathit{addr})$ \\
\line{A01} \> {\bf while}($\mathit{time} < \mathit{next.time}$){\bf do} \\
\line{A01} \>\> $\mathit{next} \gets \mathit{next.time}$ {\bf end while} \\
\line{A01} \> ${\sf return}(\mathit{next.val})$ \\
{\bf end operation}. \\
\\


{\bf operation} ${\sf merge}(\mathit{addr}, \mathit{op}, \mathit{val}, \mathit{start\_time}, \mathit{time})$ \\
\line{A01} \> $\mathit{next} \gets \mathit{hash\_table.get}(\mathit{addr})$ \\
\line{A01} \> $\mathit{node} \gets$ allocate new node \\
\line{A01} \> $\mathit{node.time} \gets \mathit{time}$; $\mathit{node.val} \gets \mathit{val}$ \\
\line{A01} \> $\mathit{node.next} \gets \mathit{next}$ \\
\line{A01} \> {\bf while}($\mathit{start\_time} < \mathit{next.time}$){\bf do} \\
\line{A01} \>\> $\mathit{merge}(\mathit{op}, \mathit{node}, \mathit{next})$ \\
\line{A01} \>\> $\mathit{next} \gets \mathit{next.next}$ {\bf end while} \\
\line{A01} \> $\mathit{merge}(\mathit{op}, \mathit{node}, \mathit{next})$ \\
\line{A01} \> $\mathit{hash\_table.set}(\mathit{addr}, \mathit{node})$ \\
{\bf end operation}. \\
\\





\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Operations of the mulit-version structure}
\label{fig:ntops}
}
\end{figure}



Idea: in all protocols need to do a memory barrier at transaction start/end (to let know safely that the transaction is no longer executing)
Is there a way we can take advantage of this in the memory structure?
Would want to be able to read directly from a time in memory without querying the location from the central structure that could have been updated
in the mean-time.



\end{document}