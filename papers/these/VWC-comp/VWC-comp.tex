% 
% % ============================================================================
% \documentclass[11pt,letterpaper]{article}
% \usepackage{epic,eepic,amsmath,latexsym,%fullpage,
% amssymb,color,times}
% \usepackage{ifthen,graphics,epsfig}
% \usepackage[english]{babel}
% 
% 
% \bibliographystyle{plain}
% 
% %============================================================================
% \usepackage{float}
% \newfloat{algorithm}{thp}{lop}
% \floatname{algorithm}{Algorithm}
% 
% \newlength{\mymargin}
% \setlength{\mymargin}{2cm}
% \usepackage[lmargin=\mymargin,rmargin=\mymargin,tmargin=\mymargin,bmargin=\mymargin]{geometry}
% \renewcommand{\baselinestretch}{0.975}
% \renewcommand{\paragraph}[1]{\vspace{0.1cm}\noindent \textbf{#1}~~}
% \let\bibitemOld\bibitem
% \renewcommand{\bibitem}[1]{\vspace{-0.14cm} \bibitemOld{#1}}
% \let\subsectionOld\subsection
% \renewcommand{\subsection}[1]{\vspace{-0.25cm}\subsectionOld{#1}\vspace{-0.15cm}}
% \let\subsubsectionOld\subsubsection
% \renewcommand{\subsubsection}[1]{\vspace{-0.3cm}\subsubsectionOld{#1}\vspace{-0.15cm}}
% 
% %\let\enumerateOld\enumerate
% %\renewenvironment{enumerate}[4]%
% %{\begin{enumerateOld}}%
% %{\end{enumerateOld}}
% %\let\itemizeOld\itemize
% %\renewenvironment{itemize}%
% %{\begin{list}{$\bullet$}{}}%
% %{\end{list}}
% %\vspace{-0.2cm}}
% 
% \clubpenalty=10000
% \widowpenalty=10000 
% 
% 
% \begin{document}


% %=====================================================================
% 
% %\title{\bf  A  virtually consistent permissive STM protocol \\
% %with  invisible read operations}
% 
% 
% \title{\bf Read invisibility,
%            virtual world consistency\\ and  permissiveness
%            are compatible}
% 
% 
% % =======================================================================
% 
% %
% {\author{       Tyler {\sc Crain} ~~~  Damien   {\sc Imbs}
%          ~~~  Michel   {\sc Raynal} \\
% %        
% IRISA, Campus de Beaulieu, 35042 Rennes Cedex, France \\
% % 
% ${\tt \{tyler.crain|damien.imbs|raynal\}@irisa.fr}$
% }
% 
% \date{}
% \maketitle
% 
% %==========================================================================
% 
% 
% \begin{abstract}
% \setlength{\baselineskip}{1.025\baselineskip}
% 
% The aim of a Software Transactional Memory (STM) is to discharge the 
% programmers from  the management of synchronization in multiprocess 
% programs that access concurrent objects. To that end, a  STM system provides 
% the programmer with the concept of a transaction. The job of the programmer 
% is to design each process  the application is made up of as a sequence of  
% transactions. A  transaction is  a piece of code that accesses concurrent 
% objects,  but  contains no explicit synchronization  statement. 
% It is the job of the underlying STM system to provide the illusion
% that each transaction appears as being executed atomically. 
% Of  course, for  efficiency,  a STM  system  has to  allow transactions  to
% execute concurrently.  Consequently, due to the  underlying STM concurrency
% management,  a transaction commits or aborts.
% 
% 
% This  paper studies the relation between two STM properties 
% (read invisibility and  permissiveness)  and  two consistency conditions  
% for  STM systems, namely, opacity  and   virtual   world consistency. 
% Both conditions ensure that any transaction (be it a committed 
% or an aborted transaction)  reads values from a consistent global state,
% a noteworthy property if one wants to prevents abnormal behavior from 
% concurrent transactions that  behave correctly when executed alone. 
% A read operation issued by a  transaction is invisible if it does not entail 
% shared  memory modifications. This  is an  important property  that favors
% efficiency and privacy. An STM  system is permissive with  respect to a
% consistency  condition  if it  accepts  every history  that satisfies  the
% condition.  This is a   crucial property as a permissive STM system  never
% aborts a transaction ``for free''. 
% The  paper  first shows that read invisibility, permissiveness  and 
% opacity  are incompatible,  which means   that there  is  no permissive STM
% system  that  implements opacity while ensuring read invisibility. 
% It then shows that invisibility, permissiveness  and opacity  are compatible. 
% To that end the paper describes a new  STM protocol called IR\_VWC\_P.
%  This protocol presents additional  noteworthy features: it uses only base
% read/write objects and locks which  are used only  at commit time; it  
% satisfies  the  disjoint  access  parallelism property;  and, in  favorable
% circumstances,  the cost of a read operation is $O(1)$. 
% ~~\\~~\\~~
% \noindent 
% {\bf Keywords}:
% Asynchronous shared memory system, Commit/abort, Concurrent object,  
% Consistency condition, Opacity,  Permissiveness, Serializability,   
% Software transactional memory,  Transaction, Virtual world consistency. 
% ~\\~\\~\\  
% 
% \noindent 
% {\bf Number of pages:} cover page + 10 pages + figures + references +
%  appendices (10 pages containing proofs and additional discussion to be read at
%  the discretion of PC members and referees).
% ~\\~\\~\\   
% 
% %\noindent 
% %{\bf Student Paper:} Tyler Crain and Damien Imbs are full-time PhD students.
% %~\\~\\~\\   
% 
% \noindent 
% {\bf Category:} Regular.
% 
% \end{abstract}
% %=========================================================================
% 
% 
% %============================================================================
% \thispagestyle{empty}
% \newpage
% \setcounter{page}{1}
% %===========================================================================






\section{Motivation}
% \vspace{0.1cm}

\subsection{Software transactional memory (STM) systems}
The most important goal of the STM abstraction is to make concurrent programming
easier and more accessible to any programmer.
By following our goal for STM defined in \ref{def:stm-def} and using our definition for a transaction \ref{def:trans-def},
arguably then all a programmer should need to know in order to use the STM abstraction is to know
the syntax for writing an atomic block, likely something as simple as
$$atomic \{ \dots \} $$
The is because following Definition \ref{def:trans-def}, a transaction always executes as an atomic block
no matter what else is going on in the system,
all the complexities and difficult synchronization is then taken care of by the
underlying STM system.
This means that, when faced to synchronization,  a programmer has 
to concentrate on where atomicity is required and not on the way it is 
realized
(unfortunately, in reality, it is actually not so simple for the programmer, as will
be seen in the later chapters in this thesis).
Like many abstractions, even if what is exposed to the programmer is a fixed well
defined interface there are many different possible implementations and different
properties that exist to provide the abstraction.

Let us consider the common example of a classical map abstraction provided by a
data structure.  A programmer might want to access and store some data in memory
and he knows that in order to do this he needs the ${\sf insert}$, ${\sf delete}$, and ${\sf contains}$
operations provided by the map abstraction.
He also knows he wants to perform these operations concurrently.
With this information he should be able to find a library providing this
functionality and use it directly in his program without knowing any additional information.

Now even though this is all that the programmer needs to know, there are many
more details to consider at a lower level.
The most obvious is that there are different data structures that can be used to
provide a map abstraction, examples such as a skip-list, binary tree, or hash table.
Choosing one of these may impact the applications performance or provide additional
functionality, yet
to the programmer just interested in the map abstraction he can use each of them the same.

At a lower level things start to get much more complex,
even when considering a single data structure there are different properties a specific implementation might ensure.
For example one might have a blocking skip-list or a non-blocking skip-list which provide
different guarantees of the progress of the operations.
Taking this a step further, different implementations might perform
better or worse depending on the workload.
For example there might exist a skip-list implementation that is memory efficient, but is slower
than another implementation that is less memory efficient.
Again though a programmer is not required to know these details (but they can still help him).

Each of these points are true in transactional memory as well.
At the most basic level all a programmer should need to know is where
to begin and end his atomic blocks.
Beneath these atomic blocks lies the STM implementation which has many different aspects.
Since the introduction of transactional memory in 1993 \cite{HM93} dozens (if not hundreds) of different properties have emerged
as well as many different STM algorithms,
with each of them ensuring a greater or fewer number of these properties and being more or less
concerned with performance.
(Some of these properties are discussed in the introduction of this thesis in section \ref{sec:details})


In an ideal world there would exist a \emph{``perfect''} STM algorithm that ensures all desirable properties
without making any sacrifices.
Unfortunately this algorithm has not yet been discovered (if it is even possible).
In fact many of these desirable properties have been little more then introduced and many of their implications
on how they affect STM algorithms or how they interact with each other has yet to be explored.
Motivated by this, this chapter examines two desirable properties that are concerned with performance,
namely \emph{permissiveness} and \emph{invisible-reads}, and how they interact with two consistency
criterion for STM systems, namely \emph{opacity} and \emph{virtual world consistency}.
As previously noted, these are just a few of the many properties that have been defined for STM systems
so this work is only touching on a much larger set of problems, but hopefully this work encourages
the study of additional properties.


%----------------------------------------------------------------------
\subsection{Some interesting and desirable properties for STM systems} \label{sec:def-perm}

\paragraph{Invisible read operation}
A read operation issued by a transaction is {\it invisible} if it does 
not entail the modification of base shared objects used to implement 
the STM system  \cite{MSHAESS06}.
This is a desirable property mainly for efficiency. 


\paragraph{Permissiveness}
The  notion  of permissiveness  has been introduced in  \cite{GHS08}
(in some sense,  it is a  very  nice generalization of the notion  of  
{\it obligation} property \cite{IR09-a}). It is on  transaction abort. 
Intuitively, an STM system is {\it permissive}  ``if it  never aborts a 
transaction unless necessary for  correctness'' (otherwise it is 
{\it non-permissive}).  More precisely, 
an STM system is permissive with respect to a consistency condition 
(e.g., opacity) if  it accepts  every history that satisfies the condition. 

As indicated in \cite{GHS08}, an STM system that checks at commit time that
the values of the objects read by a transaction have not been modified (and 
aborts the transaction if true) cannot be permissive  with respect to opacity. 
In fact other than the protocol introduced along with permissiveness in \cite{GHS08}
virtually all published STM protocols abort transactions that could
otherwise be safely committed, i.e. the protocols are not permissive.


\paragraph{Probabilistic Permissiveness}
Some STM systems are randomized in the sense that the commit/abort point of
a transaction depends on  a random coin toss. Probabilistic permissiveness is
suited to  such systems. A  randomized STM system is  {\it probabilistically
permissive} with respect to a  consistency condition if every history that
satisfies the condition is accepted with positive probability \cite{GHS08}. 




\section{Opacity and virtual world consistency}
\label{sec:opacity-and-VWC}

%----------------------------------------------------------------------
\subsection{Two consistency conditions  for STM systems}

The recurring theme throughout this document is that
the most important goal of transactional memory is ease of use,
and is the subject of this section.
We already have our syntax defined for the programmer ($atomic\{ \dots \})$) and
a basic idea of what this means, ``the code in the atomic block will appear as if
it has been executed instantaneously with respect to other transactions'', yet we need to precisely define what this
means for an STM algorithm.
At the heart of this we have consistency criterion.
These criterion precisely define the semantics of a transaction and guide the creation
of algorithms in order that the chosen criterion is satisfied.
Without a clear and precisely defined consistency criterion we loose the ease of use
that is the original intention of STM.
In this section we give a overview of two well known consistency criterion
defined for transactional memory.


\paragraph{The opacity consistency condition}
The classical consistency criterion for database
transactions is serializability \cite{P79},
roughly defined as follows: ``A history is serializable if it is equivalent to one in which
transactions appear to execute sequentially, i.e., without interleaving.''
What is important to consider when thinking about transactional memory
is that the serializability  consistency criterion 
involves only the transactions that commit. Said differently, 
a transaction  that aborts is not prevented from accessing an inconsistent
state   before aborting. 
It should be noted that serializability is sometimes strengthened in ``strict
serializability''.
Strict serializability has the additional constraint that the equivalent sequential history
must follow a real time order so that each transaction is placed somewhere between its
invocation and response time,
as  implemented  when   using   the   2-phase  locking
mechanism.
Strict serializability is often referred to as linearizability \cite{HW90}  when considering the operations
of an object instead of the system as a whole.

In contrast to database transactions that 
are usually produced by SQL queries, in  a STM  system the code  
encapsulated in a transaction is not restricted to particular patterns. 
Consequently  a transaction always has to operate on a consistent state
(no matter if it is eventually committed or not).
% To be more explicit, let   us consider the following example where 
% a transaction  contains the statement $x\leftarrow a/(b-c)$ 
% (where $a$, $b$ and $c$ are  integer data), and let us assume that 
% $b-c$ is different from $0$  in all  consistent states
% (intuitively, a  consistent state is  a global state that,  considering only
% the committed transactions,  could have existed at some real time instant). 
% If the values of $b$ and $c$ read by a transaction come from 
%  different states, it is possible  that the transaction obtains values such
% as $b=c$ (and  $b=c$ defines an inconsistent  state). If this 
% occurs,  the transaction  throws  a divide by zero  exception  that  has to  be
% handled by the process that invoked the corresponding
% transaction.
If this is not ensured by the STM system, then undesirable
behaviors such as divide by zero exceptions can occur
(an example of an execution in which such an exception occurs
is described in section \ref{sec:int-correct} of the introduction).
Even worse undesirable  behaviors can  be
obtained when  reading values from inconsistent  states. 
This occurs for example when an inconsistent state provides a transaction 
with values that generate infinite loops.
Such  bad  behaviors have  to  be prevented in  STM systems: 
whatever its fate (commit or abort) a transaction has to see always  
a consistent  state of  the data it  accesses. The aborted transactions
have to be harmless.  



Informally suggested  in   \cite{DSS06},  and  formally introduced  
and investigated in \cite{GK08}, the  {\it   opacity} consistency condition
requires  that  no transaction, at any time, reads  values from an inconsistent global 
state  where, considering only the committed transactions,  
a  {\it consistent  global  state} is defined as the  
state of the shared memory at some real time instant. 
%Opacity  is the  same as  strict serializability when  we consider all the
%committed  transactions, plus an  appropriate read prefix for each aborted
%transaction, as defined below.  
%
Let  us  associate with each  aborted  transaction $T$ 
its execution prefix (called {\it read prefix}) that contains all its  
read operations  until  $T$  aborts  (if
the  abort is  entailed by  a read, this  read is not included in the prefix). 
An  execution of a set of  transactions satisfies the {\it opacity} 
condition  if (i) all   committed transactions plus  
each aborted transaction reduced to its read prefix appear  
as if they  have been  executed sequentially and (ii)  
this sequence respects the transaction real-time occurrence order.
%We call {\it witness sequential execution} such a sequence.
%Examples  of  protocols  implementing  the  opacity   property,  each  with
%different additional features, can be found in \cite{DSS06,IR08,IR09,RFF07}. 

Here let us return to our high level Definition \ref{def:trans-def} of a transaction that
this document is focusing on.
% Importantly the correctness condition of opacity fits well with this definition.
The definition says that a transaction is ``executed atomically exactly once
taking in consideration all parts of the system''.
Even though the whole system is not considered, the opacity condition fits
in this definition because
in an STM such a system, transactions are executed atomically
with respect to each other and aborted transactions making no visible
impact on the system.
Therefore, when considering the interaction between transactions,
as STM system should use a consistency condition that ensures the same
level of safety as opacity.
Other parts of the system and the definition are considered in later chapters.


\paragraph{Virtual world consistency}
This consistency condition, introduced in \cite{IR09},  is 
weaker  than  opacity while  keeping  its spirit.  It  states  that (1)  no
transaction (committed or aborted)  reads values from an inconsistent global
state, (2)  the consistent global states read by the committed transactions 
are   mutually consistent (in the sense that they can be totally  ordered)  
but    (3)  while the  global  state read  by each aborted transaction  is
consistent from its individual point  of view, the  global states read by
any two aborted  transactions are not  required to be  mutually consistent.  
%
Said differently, virtual world consistency requires  that  
(1)  all the   committed  transactions  be serializable \cite{P79} (so  
they all  have the same ``witness sequential execution'')  or linearizable 
\cite{HW90} (if we want  this witness  execution  to also respect real time) 
and (2)  each aborted transaction  (reduced  to a read  prefix as explained
previously) reads values that are  consistent  with respect to
its \emph{causal past} only.
Informally the causal past of a transaction is some valid history as viewed by
the transaction, but not necessarily the same history as the one seen by
other transactions i.e. some transactions might be missing or ordered differently.
Causal past is defined more formally in the next section.

As two aborted transactions can have different causal pasts, 
each can read from a  global state that is consistent from its causal past
point of view, but  these two global states may be mutually inconsistent 
as aborted transactions have not necessarily the same causal past  
(hence the name {\it virtual world} consistency).

In addition to the fact that  it can allow more transactions to commit than
opacity,  one of  the most important points  of virtual world  consistency lies 
in   the fact that,  as opacity, it  prevents  bad  phenomena  (as described 
previously)    from occurring  without requiring  all the
transactions  (committed   or  aborted)  to  agree on the very same  witness
execution.  Let  us  assume  that each  transaction  behaves  correctly
(e.g. it does not entail a division  by 0, does not enter an infinite loop,
etc.) when, executed  alone, it  reads  values from  a consistent  global
state.  As, due  to the virtual world consistency  condition, no transaction
(committed or aborted)  reads from an inconsistent state,  it cannot behave
incorrectly despite  concurrency, it can only  be aborted.
This  consistency 
condition  can benefit many  STM applications as, from  its  local point
of view,  a transaction cannot  differentiate it from opacity.

So what does this mean for the programmer who plans to use transactional memory
to write his concurrent program?
Possible performance implications aside, absolutely nothing,
The programmer will see no difference between an STM protocol that is opaque
versus one that is virtual world consistent and, as a result, still keeping within our Definition \ref{def:trans-def}.
Given the first requirement of transactional memory is ease of use, this is extremely
important, virtual world consistency would be much less interesting as an STM
consistency condition if this were not true.


\subsection{Formal Definitions}
%---------------------------------------------------------------------------
%===========================================================================


This  section  defines  formally opacity  \cite{GK08} and virtual  world
consistency \cite{IR09}.
Section \ref{sec:model-and-conditions} of the first chapter described the basic model of transactions that will
be used in these definitions and throughout this chapter.
Before getting into the formal definitions of the consistency conditions, the following paragraphs describe some additional properties
of STM executions necessary for completeness.
% Then, based on these definitions, opacity and  virtual world consistency
% is defined.

\paragraph{Processes and shared objects}
An application is made up of  an  arbitrary number  of  processes  and  $m$
shared  objects.  The processes are denoted $p_i$, $p_j$, etc., 
while the  objects are  denoted $X,Y,\ldots$, where each id $X$ is such 
that $X \in \{1,\cdots,m\}$.   Each process consists of  a sequence of 
transactions (that are not known in advance).
Each of shared objects is an atomic read/write object. 
This means  that the read and  write operations issued on  such an  object
$X$  appear as  if they have  been executed  sequentially, and this 
``witness sequence'' is  legal (a read returns the value written by the  
closest write  that precedes it in this sequence) and respects the real time 
occurrence  order on the operations on $X$ (if  $op1(X)$  terminates  before
$op2(X)$  starts, $op1$ appears before $op2$ in the witness sequence 
associated with $X$). 


The notations $\exists~ X.{\sf read}_T(v)$  and $\exists~ X.{\sf write}_T(v)$ 
are  used as  predicates to  state whether a transaction  $T$ has issued a
corresponding read or write operation. 

\paragraph{Incremental snapshot}
As  in \cite{BSW79},  we assume  that the behavior of a transaction $T$  
can be decomposed in  three sequential steps:  
it first reads  data objects,  then does local computations and 
finally   writes  new values  in some  objects, which means
that  a  transaction can  be  seen as  a software 
${\sf read\_modify\_write()}$ operation that is 
dynamically defined  by  a process. (This model is for 
reasoning, understand and  state properties on STM systems.  
It only requires that everything appears as described  in the model.)


The read set is  defined  incrementally,  which  means  that a 
transaction  reads  the objects of  its read set  asynchronously  one after
the other (between  two consecutive reads, the transaction 
can  issue local  computations   that  take  arbitrary, but finite,
durations). We  say  that the  transaction $T$ computes an  {\it incremental
snapshot}.  This snapshot has to be {\it consistent} which
means that there is a time frame in which these values have co-existed 
(as we will see later, different consistency conditions consider different  
time frame  notions). 

If it reads  a  new  object whose  current  value makes  inconsistent  its 
incremental snapshot, the transaction   is  directed to  abort. 
If the transaction is not aborted during its read 
phase, $T$ issues local computations. Finally,  if the transaction  is  
an update transaction, and its  write operations  can be issued 
in  such a way that the transaction  appears as  being executed
atomically,   the objects of its write set are updated  and the transaction
 commits.   Otherwise, it  is  aborted.

\paragraph{Read prefix of an aborted transaction}
A read prefix is associated with every transaction that aborts.
This read prefix contains all its read operations if the transaction 
has not been aborted  during its read phase.  If it has been  aborted during 
its read phase, its read prefix contains all read operations it has issued 
before the read that entailed the abort.  Let us observe that the values 
obtained by the read operations of the read prefix of an aborted transaction 
are mutually consistent (they are from a consistent global state). 


%---------------------------------------------------------------------------
\Xomit{%  OMITTED%%%%%%%%%%%
\subsection{The incremental read + deferred update model}
In this transaction system model, each transaction $T$ uses a local working
space.  
When  $T$ invokes $X.{\sf  read}_T()$  for  the first   time, it  reads the
value of $X$ from  the shared  memory and copies it into its  local working
space. Later  $X.{\sf  read}_T()$ invocations  (if any)  use this copy.
So, if $T$  reads $X$ and then $Y$, these reads  are done incrementally, and
the state of the shared memory may  have changed in between. 
As already said, one usually says  that the  transaction $T$ 
computes an  {\it incremental snapshot}.


When  $T$ invokes $X.{\sf write}_T(v)$,  it writes  $v$ into  its working
space (and does not access the  shared memory). 
Finally, if $T$ is not aborted, 
it copies  the values written (if  any) from its
local working  space to  the shared memory.  (A  similar   deferred  update
model  is used  in some  database transaction systems.)  
} % end of omit 

%-------------------------------------------------------------------------

\subsection{Base consistency definitions}
\label{sec-transaction-histories}

\paragraph{Preliminary remark}
Some of the  notions that follow can be seen as read/write counterparts of
notions encountered in message-passing systems (e.g., partial order and 
happened before relation \cite{L78}, consistent cut, causal past and 
observation \cite{BM93,SM93}). 


%---------------------------------------------------------------------------
\Xomit{%  OMITTED%%%%%%%%%%%
\paragraph{Events at the shared memory level} 
Each transaction generates events  defined as follows. 
%
\begin{itemize}
\vspace{-0.2cm}
\item 
Begin and end events. 
The event denoted $B_T$ is  associated  with the  beginning of the 
transaction $T$, while the event  $E_T$ is associated with its termination. 
$E_T$ can be of two types, namely $A_T$ and $C_T$, where  $A_T$ is 
the event ``abort of  $T$'', while $C_T$  is the event ``commit of  $T$''. 
%
\vspace{-0.2cm}
\item 
Read events.
The event denoted $r_T(X)v$ is associated with the atomic read of $X$ (from
the shared  memory) issued by the   transaction $T$. The  value $v$ denotes
the value returned by the read. 
If the value $v$, or  $T$, is irrelevant $r_T(X)v$ is abbreviated  
$r_T(X)$, or  $r(X)v$ or  $r(X)$. 
The notation  $r_T(X)v \in T$, or  $r(X)v \in T$, or $r(X) \in T$, is used 
to  emphasize that $r_T(X)v$ is an event of $T$. 
%
\vspace{-0.2cm}
\item 
Write events.
The event denoted $w_T(X)v$ is associated with the atomic write of the value 
$v$ in  the shared object $X$  (in the shared memory). 
If the value $v$ is irrelevant $w_T(X)v$ is abbreviated   $w_T(X)$.
Without loss of generality we assume that no two writes on the same object 
$X$ write the same value. 
We also assume that all objects are initially written by a fictitious 
transaction. Similarly to the previous item, the notation 
$w_T(X)v \in T$, or $w(X)v \in T$, or $w(X) \in T$, is used to emphasize 
that $w_T(X)v$ is an event of  $T$. 
\end{itemize}

\paragraph{Shared memory history} 
At the shared memory level, only the events  such as $B_T$, $E_T$, $r_T(X)v$ 
and $w_T(X)v$ are perceived. Let $H$ be the set of all these events.  
Moreover, as $r_T(X)v$ and $w_T(X)v$ correspond to the execution of base 
atomic operations, the set of all the begin, end, read and write events 
can be totally ordered. This total order,  denoted  $\widehat{H}=(H,<_H)$,  
is called a {\it shared memory history}. 
}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%-----------------------------------------------------------------------


\paragraph{{\it Strong} transaction history} 
The execution of a set of transactions is represented by a 
partial   order  $\widehat{\mathit{PO}}=   (PO,  \rightarrow_\mathit{PO})$,
called {\it transaction history}, 
that states  a structural property of the execution of these transactions
capturing the order of these transactions as issued by the processes 
and in agreement with the values they  have read. More formally, we have:
%
\begin{itemize}
\vspace{-0.2cm}
\item $PO$ is the set of  transactions including all committed transactions 
plus all  aborted transactions (each reduced to its read prefix).  
\vspace{-0.2cm}
\item $T1 \rightarrow_\mathit{PO} T2$ (we say ``$T1$ precedes $T2$'') if
one of the following is satisfied: 
\begin{enumerate}
\vspace{-0.2cm}
\item ${\sf Strong~process~ order}$.
$T1$ and $T2$ have been issued by the same process,  with $T1$ first.
%
\vspace{-0.2cm}
\item ${\sf Read\_from~order}$. 
$\exists ~ X.{\sf write}_{T1}(v)~ \wedge ~ \exists ~ X.{\sf read}_{T2}(v)$. 
This is denoted   $T1 \rf{X} T2$. 
(There is an object $X$ whose value $v$ written by $T1$ has been read by $T2$.)
%
%\vspace{-0.2cm}
\vspace{-0.1cm}
\item ${\sf Transitivity}$. 
$\exists T:$  $(T1 \rightarrow_\mathit{PO} T)  \wedge ~ 
(T \rightarrow_\mathit{PO} T2)$.  
\end{enumerate}
\end{itemize}
\vspace{-0.2cm}

\paragraph{{\it Weak} transaction history} 
The definition of a  weak transaction history is the same as the one of
a  strong transaction history  except for the ``process order''
 relation that is weakened as follows:
\begin{itemize}
\vspace{-0.2cm}
\item ${\sf Weak~process~ order}$.
$T1$ and $T2$ have been issued by the same process with $T1$ first, 
and  $T1$ is a committed transaction. 
%
\end{itemize}
\vspace{-0.2cm}
This defines a less constrained  transaction history. 
In a weak transaction history,  no transaction ``causally  depends'' 
on an aborted transaction (it has no successor in the partial order). 



\paragraph{Independent transactions and sequential execution}
Given a partial order $\widehat{PO}=(PO,\rightarrow_{PO})$
that models a transaction execution, two transactions $T1$ and $T2$ are 
{\it independent} (or concurrent) if  neither is ordered before the other:  
$\neg(T1 \rightarrow_\mathit{PO} T2)~\wedge~ 
\neg(T2 \rightarrow_\mathit{PO} T1)$. 
An  execution  such that  $\rightarrow_\mathit{PO}$ is a total order, 
is a {\it sequential} execution.  



\paragraph{Causal past of a transaction}
Given a partial order  $\widehat{PO}$ defined on  a set of transactions, the 
{\it  causal past}  of a  transaction $T$,  denoted $past(T)$,  is  the set
including $T$ and all the transactions $T'$  such that 
$T' \rightarrow_\mathit{PO} T$. 

Let us observe that, when   $\widehat{PO}$  is a weak transaction history, 
an  aborted transaction $T$  is   the only aborted transaction contained in
its causal past $past(T)$.  Differently, in a strong transaction history, 
an aborted transaction always causally precedes the next transaction 
issued  by the  same  process.  As we will see, this apparently  small   
difference in the definition  of strong and weak transaction partial  
orders has a  strong influence on the  properties of the corresponding 
STM systems. 





\paragraph{Linear extension}
A linear extension  $\widehat{S}=(S,\rightarrow_{S})$ of a partial order 
$\widehat{PO}=(PO,\rightarrow_{PO})$ is a topological sort of
this partial order, i.e., 
%
\begin{itemize}
\vspace{-0.2cm}
\item $S=PO$ (same elements), 
%
\vspace{-0.2cm}
\item $\rightarrow_S$ is a total order, and 
%
\vspace{-0.2cm}
\item $(T1 \rightarrow_{PO} T2)  \Rightarrow (T1 \rightarrow_S T2)$ 
(we say  ``$\rightarrow_S$ respects $\rightarrow_{PO}$''). 
\end{itemize}
\vspace{-0.2cm}



%----------------------------------------------------------------------
\paragraph{Legal transaction}
The notion of legality is crucial for defining a consistency condition. 
It expresses the fact that a transaction does not read an overwritten value. 
More  formally, given a  linear extension $\widehat{S}$,  a  transaction $T$   
is {\it legal}  in $\widehat{S}$   if, 
for each $X.{\sf read}_{T}(v)$  operation, there is a committed 
transaction $T'$ such that: 
%
\begin{itemize}
%
\vspace{-0.2cm}
\item $T'  \rightarrow_S T$ and $\exists~ X.{\sf write}_{T'}(v)$, and  
%
\vspace{-0.2cm}
\item $\nexists~ T''$ such that 
$T'  \rightarrow_S T'' \rightarrow_S T$ and $\exists~ X.{\sf write}_{T''}()$. 
\end{itemize}
\vspace{-0.2cm}
%
If all transactions are legal, the linear extension  $\widehat{S}$ is legal. 


In the following,  a  legal  linear extension  of a  partial  order, that
models an  execution of a set  of transactions,  is sometimes called a 
{\it sequential witness} (or witness) of that execution. 


\paragraph{Real time order}
Let $\rightarrow_\mathit{RT}$  be the {\it  real time} relation  defined as
follows:  $T1  \rightarrow_\mathit{RT} T2$  if  $T1$  has terminated 
before  $T2$ starts. 
This relation (defined either on  the whole set of  transactions, or only  
on the committed transactions) is  a partial order.  In the  particular case
where it is  a total order,  we  say that we have a real time-complying
sequential execution. 
% Let us notice that this  partial order relation 
%$\rightarrow_\mathit{RT}$    on transactions  is defined  from  the  total
%order relation  on events  denoted  $<_H$.  

A linear extension  $\widehat{S}=(S,\rightarrow_{S})$ of a partial order 
$\widehat{PO}=(PO,\rightarrow_{PO})$ is real time-compliant if 
$\forall T,T'\in S$: 
$ (T \rightarrow_\mathit{RT} T')  \Rightarrow  (T \rightarrow_{S} T')$.



%---------------------------------------------------------------------------
\subsection{Opacity and virtual world consistency}
Both  opacity and  virtual world  consistency ensures  that  no transaction
reads  from  an  inconsistent global state.  If each transaction taken 
alone is correct, this prevents bad phenomena such as the ones described  
in the Introduction (e.g., entering an infinite loop). 
Their main  difference lies in the  fact that opacity considers strong
transaction histories while virtual world consistency considers 
weak transaction histories. 

% \vspace{-0.2cm}
\begin{defin}
A strong transaction  history satisfies the  {\it   opacity}  consistency
condition if it has a real time-compliant  legal  linear extension. 
\end{defin}
% \vspace{-0.2cm}
%

Examples  of  protocols  implementing  the opacity   property,  each  with
different additional features, can be found in \cite{DSS06,IR08,IR09,RFF07}. 

% \vspace{-0.2cm}

\begin{defin}
A weak transaction  history satisfies the  {\it   virtual world}
consistency condition if 
(a)  all its committed transactions have  a %realtime-compliant 
legal linear  extension and 
(b) the causal past of each aborted transaction has a legal linear extension. 
\end{defin}
% \vspace{-0.2cm}


A protocol  implementing   virtual world consistency 
can be found in \cite{IR09} where it is also shown that 
any opaque history is virtual world consistent. In contrast,  
a virtual world  consistent history is not necessarily  opaque.


%---------------------------------------------------------------
\begin{figure}[ht!]
\centering
\scalebox{0.30}{\input{VWC-comp/figures/virtual-world-consistency.pdf_t}}
%\scalebox{0.40}{\input{virtual-world-consistency.pstex_t}}
\caption{Examples of causal pasts}
\label{fig:example-linear-extensions}
\end{figure}
%---------------------------------------------------------------




To give a better  intuition of the virtual world  consistency condition,
let us consider 
the execution depicted on Figure~\ref{fig:example-linear-extensions}. There 
are two processes: $p_1$ has sequentially issued $T_1^1$,  $T_1^2$,  $T_1'$
and $T_1^3$, while $p_2$ has issued   $T_2^1$,  $T_2^2$,  $T_2'$ and
$T_2^3$.  The transactions associated with a black dot have committed, while
the ones with a gray square have aborted. From a dependency point of view, 
each   transaction   issued  by   a   process  depends   on   its  previous
committed   transactions  and    on  committed  transactions   issued by
the  other  process as  defined  by the  read-from relation due to the  
accesses to the shared  objects, (e.g., the label $y$ on the dependency edge 
from  $T_2^1$  to  $T_1'$ means  that   $T_1'$ has  read from $y$ a  value 
written by  $T_2^1$). In contrast, since here we consider that an  aborted  
transaction does not write shared objects, there is no dependency edges 
originating from it. The causal past of the aborted transactions   $T_1'$
and   $T_2'$ are indicated on the figure  (left of the corresponding dotted
lines).   The values read by  $T_1'$ (resp.,  $T_2'$)
are consistent with respect to its causal past dependencies.



\section{Invisible reads, permissiveness, and consistency}
In the previous section several interesting properties and consistency conditions
for STM have been defined.
In this section we examine the some of the implications of these properties
on STM algorithms.

We start by proving that an STM protocol cannot implement invisible reads, opacity,
and permissiveness at the same time.
Recalling that a permissive protocol is one that
never aborts a 
transaction unless necessary for  correctness (as defined earlier in Section \ref{sec:def-perm}).
This is important because it shows that no matter how well we keep track of
the interactions between transactions, an opaque STM protocol will have to abort
transactions unnecessarily if invisible reads are used.
We then show that by simply replacing virtual world consistency for opacity
as the consistency condition no transactions need to be aborted unnecessarily.
Importantly, as discussed previously, changing virtual world consistency for opacity makes no difference
to the meaning of a transaction for the programmer, still following
our high level Definition \ref{def:trans-def} of transactions.

%=========================================================================
\subsection{Invisible reads, opacity and permissiveness are incompatible} 
\label{sec:opacity-impos}

\begin{theorem}
\label{proof:opacity-impossibility}
Read invisibility,  opacity   and  permissiveness   (or   probabilistic
permissiveness) are incompatible. 
\end{theorem}
\vspace{-0.2cm}


\begin{proofT}
Let us first consider   permissiveness. 
The proof follows from a simple counter-example where three transactions 
$T_1$, $T_2$ and $T_3$ issue  sequentially the following operations
(depicted in  Figure \ref{fig:opacity-impossibility}).
%
\begin{enumerate}
\vspace{-0.15cm}
\item  $T_3$ reads object $X$. 
%
\vspace{-0.25cm}
\item Then $T_2$ writes $X$ and terminates.
If the STM system is permissive it has to  commit $T_2$. This is because 
if (a) the system would abort $T_2$ and (b) $T_3$ would be made up of 
only the  read of $X$,
aborting $T_2$ would make the  system non-permissive.  Let us notice  that, 
at the time at which  $T_2$ has to be committed or aborted,  the future 
behavior of $T_3$ is not known  and $T_1$  does not yet exist.  
%
\vspace{-0.25cm}
\item Then $T_1$ reads $X$ and $Y$. 
Let us observe that the STM system  has not to abort $T_1$. This is because
when $T_1$  reads $X$  there is no  conflict with another  transaction, and
similarly when $T_1$ reads $Y$. 
%
\vspace{-0.25cm}
\item Finally, $T_3$ writes $Y$ and terminates. let us observe that 
 $T_3$  must  commit in a permissive system where read operations 
(issued by other processes) are invisible. This  is because,
due to read  invisibility,  $T_3$ does not know that $T_1$ has previously
issued a read of $Y$. Moreover,  $T_1$ has not yet terminated and terminates
much later  than $T_3$. Hence, whatever the commit/abort fate of $T_1$, 
due to read invisibility, no information on  the fact that  $T_1$ has
accessed $Y$  has been passed from $T_1$ to $T_3$: when the fate of $T_3$ 
has to be decided, $T_3$ is not aware of the existence of $T_1$.

%%(Let us  remark that, a  non-permissive system would  abort  $T_3$.
%%This is because when, at which $T_3$ terminates, it 
%%tries to  validate the read of $X$ 
%%-in order to check  if the read of $X$ and the write of $Y$ by $T_3$ can 
%%appear as being executed  atomically-, it would  discover thanks to the 
%%visible read of $T_1$ that its read of $X$  has been overwritten .) 
\end{enumerate}

%%
\begin{figure}[htb!]
\centering{
  \scalebox{0.45}{\input{VWC-comp/figures/fig-opacity-impossibility.pdf_t}}
\caption{Invisible reads, opacity and permissiveness are incompatible}
%
\label{fig:opacity-impossibility}
}
\end{figure}
%%




\noindent
The strong transaction history $\widehat{PO}=(\{T_1,T_2,T_3\}, 
\rightarrow_{PO})$  associated with the previous execution is such that: 
%
\begin{itemize}
\vspace{-0.15cm}
\item   $T_3 \rightarrow_{PO}  T_2$ (follows from the fact that $T_2$ 
overwrites the value of $X$ read by $T_3$). 
\vspace{-0.25cm}
\item   $T_2 \rightarrow_{PO}   T_1$ (follows from the fact that $T_1$ 
reads the  value of  $X$ written  by  $T_2$). Let  us observe that this is
independent from the fact that  $T_1$ will be later  aborted or committed. 
(If $T_1$ is aborted it is reduced to its read prefix 
``$X.{\sf  read}()$;  $Y.{\sf  read}()$''  that  obtained values from a
consistent global state.)   
\vspace{-0.25cm}
\item Due to the sequential accesses on $Y$ that is read by $T_1$ and 
then written by $T_3$, we have  $T_1 \rightarrow_{PO} T_3$. 
\end{itemize}
\vspace{-0.15cm}
It follows from the previous item that $T_1 \rightarrow_{PO}   T_1$. 
A contradiction  from which we conclude that there is no protocol 
with invisible read operations that both is permissive and satisfies opacity. 


Let us now consider probabilistic permissiveness. 
Actually,  the  same counter-example and the same reasoning as before
applies. As  none of $T_2$ and $T_3$ violates opacity,
a probabilistic STM system 
that  implements opacity  with invisible  read operations has  a positive
probability of  committing both  of them. As  read operations  are invisible,
there is positive probability that both read operations on $X$ and $Y$ 
issued by $T_1$ be accepted by the STM system. It then follows that the 
strong transaction history  $\widehat{PO}=(\{T_1,T_2,T_3\}, 
\rightarrow_{PO})$  associated  with the  execution in which 
$T_2$  and  $T_3$ are  committed  while $T_1$ is aborted has a positive
probability to be accepted. It is trivial to see that this execution is the 
same as in  the non-probabilistic case for which it has been shown that 
this history is not opaque. %This concludes the proof of the theorem.
%\vspace{-0.2cm}

%Let us  remark that, a  non-permissive system would  abort  $T_3$.
%This is because when $T_3$ terminates, it tries to  validate the read of $X$ 
%-in order to check  if the read of $X$ and the write of $Y$ by $T_3$ can 
%appear as being executed  atomically-, and it then  discovers (thanks to the 
%visible read of $T_1$) that its read of $X$  has been overwritten.

From this we have that read invisibility, permissiveness, 
and opacity are  incompatible.
\renewcommand{\toto}{proof:opacity-impossibility}
\end{proofT}
\vspace{-0.2cm}   


\paragraph{Remark}
Let us  observe that any opaque system with invisible reads would be
required to abort $T_3$.  When  $T_3$ performs the ${\sf try\_to\_commit}()$ 
operation detecting that its read of $X$  has been overwritten, it must 
abort (this is because  $T_3$ has no way of knowing whether or not
$T_1$'s read exists at this point, so  $T_3$ must abort in order to ensure 
safety).  From this we have that read invisibility, permissiveness, 
and opacity are {\it incompatible} in the sense that any pair of properties 
can be satisfied only if the third is omitted.

Importantly this history can be made permissive and virtual world consistent even with read invisibility.
In order for this to be true, a virtual  world consistency protocol must then
abort transaction $T_1$. 
Then it is easy  to see that the  corresponding weak transaction history 
is virtual world consistent:  
 The  read prefix ``$X.{\sf  read}_{T_1}()$;  $Y.{\sf  read}_{T_1}()$'' 
of the aborted transaction  $T_1$
can be ordered after $T_2$ (and $T_3$ does not appear in its causal past). 
In the following sections a protocol is designed that satisfies virtual world consistency,
invisible reads, and permissiveness.







% 
% \subsection{Invisible reads, virtual world consistency and permissiveness are compatible} 
% \label{sec:vwc-pos}
% 
% \anote{UPDATE PROOF}
% 
% 
% \input{./VWC-comp/vwcinvisperm}
% 
% 
% \anote{SHOULD ALSO TALK ABOUT PROB PERM FOR THE PROOF}
% 
% 
% 
% \paragraph{Remark}
% The previous section (section \ref{sec:opacity-impos}) shows that opacity is a too strong consistency condition 
% when one wants  both  read invisibility and permissiveness
% while this section shows that virtual world consistency should be used instead.
% 
% Let us consider the execution in figure \ref{fig:opacity-impossibility} that was used to show that opacity, invisible reads, and
% permissiveness are incompatible.
% Unsurprisingly this history can be made permissive and virtual world consistent even with read invisibility.
% In order for this to be true, a virtual  world consistency protocol must then
% abort transaction $T_1$. 
% Then it is easy  to see that the  corresponding weak transaction history 
% is virtual world consistent:  
%  The  read prefix ``$X.{\sf  read}_{T_1}()$;  $Y.{\sf  read}_{T_1}()$'' 
% of the aborted transaction  $T_1$
% can be ordered after $T_2$ (and $T_3$ does not appear in its causal past). 









%=========================================================================


\section{A protocol satisfying permissiveness and virtual world consistency with read invisibility}

% Even though the previous section shows that it is possible to have an STM protocol with read invisibility,
% permissiveness, and virtual world consistentency, it does not show that it is realistic to implement.
This section introduces a protocol that satisfies permissiveness and virtual world consistency with read invisibility
efficiently using realistic operations available in most hardware.


\subsection{Step 1: Ensuring virtual world consistency with read invisibility}
\label{sec:algorithm-V1}


The protocol (named as IR\_VWC\_P)  is built  is two
steps.  This section  presents  the  first step,  namely,  a protocol  that
ensures  virtual consistency  with  invisible read  operations. The  second
step  (Section  \ref{sec:algo-V2-permissiveness})  will  enrich  this  base
protocol to obtain  probabilistic permissiveness.





%-------------------------------------------------------------------------
\subsubsection{Base objects, STM interface, incremental reads and 
deferred updates}
%\vspace{-0.2cm}
The underlying system  on top of which  is built the STM system  is made up
of  base shared read/write  variables (also called registers)  and  locks.  
Some of the base variables are used to contain pointer values. 
As we will see, not all the  base registers  are required to be atomic. 
There is an exclusive lock per shared object. 


The STM  system provides  the process that issues a transaction  $T$ with
 four   operations. The operations 
$X.{\sf read}_T()$,   $X.{\sf  write}_T()$,  and ${\sf
try\_to\_commit}_T()$ have been already presented. 
The operation  ${\sf  begin}_T()$  is invoked by a transaction  $T$ when 
it starts.   It initializes local control variables. 


The proposed STM system is based on the incremental reads and deferred 
update strategy. Each transaction $T$ uses a local working space.  
When  $T$ invokes $X.{\sf  read}_T()$  for  the first   time, it  reads the
value of $X$ from  the shared  memory and copies it into its  local working
space. Later  $X.{\sf  read}_T()$ invocations  (if any)  use this copy.
So, if $T$  reads $X$ and then $Y$, these reads  are done incrementally, and
the state of the shared memory may  have changed in between. 
As already explained, this is  the  {\it incremental snapshot} strategy. 


When  $T$ invokes $X.{\sf write}_T(v)$,  it writes  $v$ into  its working
space (and does not access the  shared memory) and always returns $ok$. 
%
Finally, if $T$ is not aborted while it is executing 
${\sf try\_to\_commit}_T()$,  it copies  the values written (if  any) from its
local working  space to  the shared memory.  (A  similar   deferred  update
model  is used  in some  database transaction systems.)  

%-------------------------------------------------------------------------
\subsubsection{The underlying data structures}
%\vspace{-0.2cm}
\paragraph{Implementing a transaction-level shared object}  
%
Each  transaction-level shared object $X$ is  implemented by  a list.  
Hence, at the implementation level, there is a shared array $PT[1..m]$ 
such that  $PT[X]$ is a pointer to the list associated with $X$. 
This list is made up of cells. Let $CELL(X)$ be such a cell. It is made up of 
the following fields (see Figure \ref{fig:list-implementation-register}).
%
\begin{itemize}  
%\vspace{-0.2cm}
\vspace{-0.1cm}
\item  
$CELL(X).value$ contains the  value $v$  written into $X$ by some 
transaction $T$. 
%
\vspace{-0.2cm}
\item   
$CELL(X).begin$  and $CELL(X).end$  are two dates (real numbers) such 
that the right-open time  interval  $[CELL(X).begin.. CELL(X).end[$  
defines the lifetime of the value kept in  $CELL(X).value$.  
Operationally,  
$CELL(X).begin$ is the commit time of the transaction that wrote 
$CELL(X).value$ and  $CELL(X).end$ is the date from which $CELL(X).value$ 
is no longer valid.
%
\vspace{-0.2cm}
\item 
$\mathit{CELL(X)}.last\_read$ contains the  commit date of the latest
transaction that  read  object $X$ and returned the value $v=CELL(X).value$.
%
\vspace{-0.2cm}
\item 
$CELL(X).next$ is a pointer  that points to the cell 
containing the first value  written into $X$ after $v=CELL(X).value$.
$CELL(X).prev$ is a  pointer in the other direction.

It is important to notice that none of these pointers are used 
in the protocol (Figure~\ref{fig:ttc-protocol})
that ensures virtual world consistency and read invisibility.
$CELL(X).next$ is required only when one wants to recycle
e inaccessible 
cells (see Section \ref{sec:garbage-collection}).  Differently,
$CELL(X).next$ will be  used to obtain permissiveness
(see Section \ref{sec:algo-V2-permissiveness}).
\end{itemize}


%%
\begin{figure}[htb!]
\centering{
  \scalebox{0.45}{\input{VWC-comp/figures/fig-implementing-register-X.pdf_t}}
\caption{List implementing a transaction-level shared object $X$}
%
\label{fig:list-implementation-register}
}
\end{figure}
%%


No field of a cell is required to be an atomic read/write register of 
the underlying  shared memory. Moreover, all fields (but  
$CELL(X).last\_read$)  are simple write-once registers. 
%
Initially $PT[X]$ points to a list made up of a  single cell 
containing the  tuple $\langle v_{init},0,+\infty,0,\bot,\bot\rangle$,  
where $v_{init}$ is the initial value of~$X$. 



\paragraph{Locks}
An exclusive access lock is associated with each read/write shared object 
$X$. These locks are used only in the ${\sf try\_to\_commit}()$ operation,
which means that neither $X.{\sf read}_T()$ nor $X.{\sf write}_T()$ 
is lock-based. 


\paragraph{Variables  local to each process}
Each process $p_i$ manages a local variable  denoted $last\_commit_i$ 
whose scope is the entire computation. This variable 
(initialized to $0$)  contains the commit date associated with the last 
transaction committed by $p_i$. Its aim is to ensure that the transactions 
committed by $p_i$  are serialized according to  their commit order. 


In addition to  $last\_commit_i$, a process $p_i$ manages  the 
following local variables whose scope  is the duration of the transaction $T$ 
currently executed by process $p_i$. 
%
\begin{itemize}  
\vspace{-0.2cm}
\item   
$window\_bottom_T$ and   $window\_top_T$  are  two  local variables
that  define  the  time  interval  during  which  transaction  $T$ could 
be committed. This interval is $]window\_bottom_T..window\_top_T[$ 
(which means that its bounds do not belong to the interval). 
It is initially equal to  $]last\_commit_i..+\infty[$. 
Then, it can only shrink.  If it becomes empty (i.e., 
$window\_bottom_T \geq window\_top_T$), transaction $T$ has to be aborted. 
%
\vspace{-0.2cm}
\item  
$lrs_T$  (resp.,  $lws_T$) is  the read (resp.,  write)  set  of transaction 
$T$.  Incrementally updated, it  contains the identities of the 
transaction-level  shared  objects $X$ that $T$ has   read (resp., written)
up to now.  
%
\vspace{-0.2cm}
\item 
$lcell(X)$ is a local cell whose aim is to contain the values that have been 
read from the cell pointed to by $PT[X]$ or will be added to that list if 
$X$ is  written  by $T$. 
In addition  to the six previous  fields, it contains  an additional field
denoted $lcell(X).origin$ whose meaning is as follows.
%
If $X$ is read by $T$,  $lcell(X).origin$ contains  
the value of the pointer $PT[X]$ at the time $X$ has been read.
If $X$ is only written  by $T$,  $lcell(X).origin$ is useless. 
\end{itemize}


\paragraph{Notation for pointers}
$PT[X]$, $cell(X).next$ and  $lcell(X).origin$ are pointer variables. 
The following pointer notations are used. Let $PTR$ be a pointer
variable.  $PTR \downarrow$  denotes the variable pointed to by $PTR$. 
Let $ \mathit{VAR}$ be a non-pointer  variable.  $\uparrow \mathit{VAR}$  
denotes a pointer  to  $\mathit{VAR}$.  Hence,  
$PTR \equiv ~ \uparrow (PTR \downarrow)$ and 
$\mathit{VAR} \equiv (\uparrow  \mathit{VAR}) \downarrow)$. 







%==================================================================
\begin{figure}[htb!]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
\resetline
\begin{tabbing}
aaaaa\=aa\=aaaaa\=aa\=\kill %~\\


{\bf operation} ${\sf begin}_T()$:\\
\line{BA01} \> $window\_bottom_T \gets last\_commit_i$;
	       $window\_top_T \gets +\infty$;
	       $lrs_T \gets \emptyset$;
               $lws_T \gets \emptyset$. \\

{\bf end operation}. \\
\\
% ~~~====================================================================================\\

{\bf operation}  $X.{\sf read}_T()$: \\

\line{BA02} \>   {\bf if} \= 
  ($\nexists$ local cell associated with the R/W shared object $X$)  
   {\bf then}\\

\line{BA03} \>\>   allocate local space denoted $lcell(X)$;\\


\line{BA04}  \>\> 
                  $x\_ptr \leftarrow PT[X]$;\\

\line{BA05}  \>\> $lcell(X).value 
                  \leftarrow (x\_ptr\downarrow).value$;\\


\line{BA06} \>\> 
   $lcell(X).begin 
                 \leftarrow (x\_ptr \downarrow).begin$; \\

\line{BA07} \>\>  $lcell(X).origin \leftarrow x\_ptr$;\\


\line{BA08} \>\>  $window\_bottom_T \leftarrow 
                  \max(window\_bottom_T, lcell(X).begin)$;\\

\line{BA09} \>\> $lrs_T \leftarrow lrs_T \cup X$;\\

\line{BA10} \>\>
      {\bf for each} $(Y \in lrs_T)$ {\bf do} $window\_top_T \leftarrow 
          \min\big(window\_top_T,
     (lcell(Y).origin\downarrow).\mathit{end} \big)$ {\bf end for};\\

\line{BA11} \>\> {\bf if} $(window\_bottom_T \geq window\_top_T)$ {\bf then}
 		 ${\sf return}(abort)$ {\bf end if}\\

%\line{BA11} \>\> $lrs_T \leftarrow lrs_T \cup X$\\

\line{BA12} \>   {\bf end if}; \\

\line{BA13} \>   ${\sf return}~(lcell(X).value)$. \\

{\bf end operation}. \\
\\
%~\\
%~~~~====================================================================================\\


{\bf operation}  $X.{\sf write}_T(v)$: \\

\line{BA14} \>  {\bf if} \= 
      ($\nexists$ local cell associated with the R/W shared object $X$) 
         {\bf then} allocate local space $lcell(X)$  {\bf end if}; \\


\line{BA15} \> $lws_T \gets lws_T \cup {X}$;\\


\line{BA16} \> $lcell(X).value \gets v$; \\

\line{BA17} \> ${\sf return}(ok)$.\\

{\bf end operation}. \\
\\



% ~~~====================================================================================\\


{\bf operation} ${\sf try\_to\_commit}_T()$: \\

\line{BA18} \> lock all the objects in $lrs_T \cup lws_T$; \\

\line{BA19} \> {\bf for each} $(Y \in lrs_T)$ {\bf do} $window\_top_T \leftarrow 
          \min\big(window\_top_T,
     (lcell(Y).origin\downarrow).\mathit{end} \big)$ {\bf end for};\\

\line{BA20} \> {\bf for each} $(Y \in lws_T)$ {\bf do} 
              
               $window\_bottom_T \leftarrow 
               \max((PT[Y]\downarrow).last\_read, window\_bottom_T)$ 

               {\bf end for}; \\
	
\line{BA21} \> {\bf if} $(window\_bottom_T \geq window\_top_T)$ {\bf then}
      release all locks and disallocate all local cells; 		
      ${\sf return}(abort)$ {\bf end if};\\


\line{BA22} \> $commit\_time_T \leftarrow$ 
         select a (random/heuristic) time value
         $\in ~]window\_bottom_T.. window\_top_T[$; \\

\line{BA23} \> {\bf for each} $(X \in lws_T)$ {\bf do} 
       $(PT[X] \downarrow).\mathit{end} 
            \leftarrow \mathit{commit\_time}_T$  {\bf end each};\\


\line{BA24} \> {\bf for each} $(X \in lws_T)$ {\bf do} \\


\line{BA25} \>\> 
       allocate in shared memory  a new cell for $X$ denoted $CELL(X)$; \\

\line{BA26} \>\>  $CELL(X).value \gets lcell(X).value$;
                  $CELL(X).last\_read \gets commit\_time_T$;\\

\line{BA27} \>\>  $CELL(X).begin \gets commit\_time_T$; 
                  $CELL(X).end \leftarrow +\infty$;\\

\line{BA28} \>\>  $PT[X]  \leftarrow  ~ \uparrow CELL(X)$ \\

\line{BA29} \> {\bf end for};\\

\line{BA30} \> {\bf for each} $(X \in lrs_T)$ {\bf do} \\


\line{BA31} \>\>
   $(lcell(X).origin \downarrow).last\_read \leftarrow 
     \max((lcell(X).origin \downarrow).last\_read, commit\_time_T)$ \\

\line{BA32} \> {\bf end for};\\

\line{BA33} \> release all locks and disallocate all  local cells; 
               $last\_commit_i \leftarrow commit\_time_T$;\\
	
\line{BA34} \> ${\sf return}(commit)$. \\

{\bf end operation}. 
% \\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Algorithm for the operations of the protocol}
\label{fig:ttc-protocol}
}
\end{figure}
%=================================================================



























\subsubsection{The ${\sf read}_T()$ and  ${\sf write}_T()$  operations}
%\vspace{-0.1cm}
When a process $p_i$ invokes a new transaction $T$,  it first 
executes the operation ${\sf begin}_T()$ which  initializes the
appropriate  local variables. 



\paragraph{The  $X.{\sf read}_T()$ operation}
The algorithm implementing $X.{\sf read}_T()$ is described in Figure
\ref{fig:ttc-protocol}.  When $p_i$ invokes this operation, it 
returns the value locally saved in $lcell(X).value$ if  $lcell(X)$ exists
(lines  \ref{BA02} and \ref{BA13}). 
%
If  $lcell(X)$ has not yet been allocated, $p_i$ does it (line \ref{BA03}) and 
updates its  fields $value$, $begin$  and  $origin$ with the corresponding 
values obtained from the shared memory (lines \ref{BA04}-\ref{BA07}).
%
Process $p_i$ then updates $window\_bottom_T$ and $window\_top_T$.
These updates are as follows. 
\begin{itemize}  
%
\vspace{-0.2cm}
\item 
The algorithm defines the  commit time of transaction $T$ as a point of the  
time line such that $T$ could have executed all its read and write operations 
instantaneously as that time. Hence, $T$ cannot be committed before
a committed transaction $T'$  that wrote the value of a shared object $X$  
read by $T$. 
According to the algorithm implementing the ${\sf try\_to\_commit}_T()$ 
operation  (see line~\ref{BA27}), 
the commit point of such a transaction $T'$ is  the time value kept in 
$lcell(X).begin$. Hence, $p_i$ updates  $window\_bottom_T$ to 
$\max(window\_bottom_T, lcell(X).begin)$ (line  \ref{BA08}).
$X$ is then added to $lrst_T$  (line  \ref{BA09}).
%
%
\vspace{-0.2cm}
\item 
Then, $p_i$ updates  $window\_top_T$ (the top side of $T$'s  commit window,
line \ref{BA10}). 
If there is a shared object $Y$ already read by $T$  (i.e., $Y\in lrs_T$)
that has been written by some  other transaction $T''$ 
(where $T''$ is a transaction that  wrote  $Y$ after $T$ read $Y$),   
then $window\_top_T$ has to be set to  $commit\_time_{T''}$  
if  $commit\_time_{T''} <window\_top_T$.
%
According to the algorithm implementing the ${\sf try\_to\_commit}_T()$ 
operation,  
the commit point of such a transaction $T''$ is  the date kept in 
$(lcell(Y).origin\downarrow).\mathit{end}$. 
 Hence, for each $Y \in lrs_T$, $p_i$ updates  $window\_bottom_T$ to 
$\min\big(window\_top_T, (lcell(Y).origin\downarrow).\mathit{end}$
(line  \ref{BA10}).
\end{itemize}
Then, if the window becomes empty, the  $X.{\sf read}_T()$ operation 
entails the abort of transaction $T$ (line  \ref{BA11}).
If $T$ is not aborted, the value written  by $T'$ (that is  
kept in  $lcell(X).value$) is returned (line  \ref{BA13}). 




\paragraph{The  $X.{\sf write}_T(v)$ operation}
The algorithm implementing this operation is described at lines 
\ref{BA14}-\ref{BA17} of Figure \ref{fig:ttc-protocol}.
If there is no local cell associated with $X$, $p_i$ allocates one 
(line \ref{BA14}) and adds $X$ to $lws_T$ (line \ref{BA15}). 
Then it locally writes $v$ into $lcell(X).value$   (line \ref{BA16})
and return $ok$  (line \ref{BA17}).
%
Let  us observe  that  no $X.{\sf write}_T()$ operation can  entail 
the abort of a transaction. 





%--------------------------------------------------------------------------
\subsubsection{The ${\sf try\_to\_commit}_T()$ operation}
%\vspace{-0.1cm}
The algorithm implementing this operation is described in Figure 
\ref{fig:ttc-protocol} (lines \ref{BA18}-\ref{BA34}). 
A process $p_i$ that invokes ${\sf try\_to\_commit}_T()$ first locks all 
transaction-level shared objects $X$ that have been accessed by 
transaction $T$  (line  \ref{BA18}). The locking of shared  objects is done
in a canonical order in order to prevent deadlocks.


Then, process $p_i$  computes the values that define the last commit window 
of $T$ (lines  \ref{BA19}-\ref{BA20}).
The update of $\mathit{window\_top}_T$ is the same as
described in the ${\sf read}_T()$ operation. 
The update of $\mathit{window\_top}_T$ is as follows.
For each register $Y$ that $T$ is about to write in the shared 
memory (if $T$  is not aborted before), $p_i$ computes the date of the last
read of $Y$, namely the date $(PT[Y]\downarrow).last\_read$. 
In order not to invalidate this read
(whose issuing transaction has been committed), $p_i$ updates 
$window\_bottom_T$ to  $\max((PT[Y]\downarrow).last\_read, window\_bottom_T)$. 
If the  commit window of $T$ is empty, $T$ is aborted (line \ref{BA21}).
All locks are then released and all local cells are freed.

If $T$'s commit window is not empty, it can be safely committed. 
To that end  $p_i$  defines $T$'s commit time as  a finite value randomly
chosen in the current window $]window\_bottom_T.. window\_top_T[$  
(let us remind that the  bounds are outside the  window, line \ref{BA22}).  
This  time function  is such  that no  two processes  obtain the  same time
value.  



Then, before committing,  $p_i$ has to (a) apply the writes issued by $T$ 
to the shared objects and (b) update the ``last read'' dates associated with 
the shared objects it has read. 
\begin{itemize}
\vspace{-0.2cm}
\item [a.] First, for every shared object $X\in lws_T$, process $p_i$ updates  
$(PT[X] \downarrow).\mathit{overwrite}$ with $T$'s 
 commit date (line \ref{BA23}). 
When all these updates have been done,  for every shared object $X\in lws_T$,
$p_i$ allocates a new shared memory cell  $CELL(X)$  and fills in the 
four fields of $CELL(X)$ (lines \ref{BA25}-\ref{BA28}).
Process $p_i$  also has to update the pointer $PT[X]$ to its new  value
(namely $\uparrow CELL(X)$)  (line \ref{BA28}). 
%
\vspace{-0.2cm}
\item[b.] For each register $X$ that has been read by $T$, 
$p_i$ updates the field $last\_read$ to the maximum of its previous value 
and $commit\_time_T$ (lines \ref{BA30}-\ref{BA32}). 
(Actually, this base version of the protocol remains correct 
when   $X \in lrs_T$  is  replaced by  $X \in (lrs_T \setminus  lws_T)$. 
(As this improvement is no longer valid in the final version of the 
${\sf try\_to\_commit}_T()$  algorithm described in  
Figure~\ref{fig:ttc-V22-protocol}, we do not consider it in this
 base protocol.) 


\end{itemize}

Finally, after these updates of the shared memory, $p_i$ releases all its 
locks, frees the local cells it had previously allocated (line \ref{BA33}) 
and returns the value $commit$ (line \ref{BA34}). 


\paragraph{On the random selection of commit points}
It is important to notice that, choosing randomly  commit points
(line \ref{BA22}, Figure \ref{fig:ttc-protocol}),  there might be 
``best/worst'' commit  points for committed  transactions,  
where ``best point''  means that it  allows  more  concurrent 
conflicting  transactions to commit.  Random selection of a commit point 
can  be seen as  an inexpensive way to amortize the impact of ``worst'' 
commit points  (inexpensive because  it eliminates the 
extra overhead of computing which point is the best). 



%===========================================================================



%===========================================================================
\subsection{Proof of the algorithm for VWC and read invisibility}
\label{sec:algorithm-V1-proof}


Let  $\mathcal{C}$ and   $\mathcal{A}$ be the set  of committed transactions 
and the set  of aborted transactions, respectively. 
The proof consists of two parts. First, we prove that the set $\mathcal{C}$
is serializable. We then prove that that the causal past $\mathit{past(T)}$
of every transaction $T \in  \mathcal{A}$ is serializable. 
In the following, in order to shorten the proofs, 
we  abuse notations in the following way: we write "transaction $T$
executes action A" instead of "the process that executes transaction 
$T$ executes action A"  and we use "$X.{\sf write}_T()$'' as the predicate
``$T$  is a  committed  transaction and  the  operation $X.{\sf  write}_T()$
belongs to the execution".  



\subsubsection{Proof that $\mathcal{C}$ is serializable}
In order to show that $\mathcal{C}$ is serializable, we have to show that 
the partial order $\rightarrow_{PO}$ restricted to
$\mathcal{C}$ accepts a legal linear extension. More precisely, we have 
to show that there exists an order $\rightarrow_S$ on the transactions
of $\mathcal{C}$ such that the following properties hold:
\begin{enumerate}
\vspace{-0.2cm}
\item $\rightarrow_S$ is a total order,
\vspace{-0.2cm}
\item $\rightarrow_S$ respects the process order between transactions,
\vspace{-0.2cm}
\item $\forall T1, T2 \in \mathcal{C}: 
T1 \rf{} T2 \Rightarrow T1 \rightarrow_S T2$ and,
\vspace{-0.2cm}
\item $\forall T1, T2 \in \mathcal{C}, \forall X: (T1 \rf{X} T2)
\Rightarrow (\nexists T3: X.{\sf write}_{T3}() 
       \wedge T1 \rightarrow_S T3 \rightarrow_S T2)$.
\end{enumerate}

In the following proof, $\rightarrow_S$ is defined according to the value
of the $\mathit{commit\_time}$ variables of the committed transactions.
If two transactions have the same $\mathit{commit\_time}$, they are ordered 
according to the identities of the processes that issued them.

\begin{lemma}
\label{lemma:total}
The order $\rightarrow_S$ is a total order.
\end{lemma}
\begin{proofL}
 The proof follows directly from the  fact that $\rightarrow_S$ is defined
 as a total order on the commit times of the transactions of ${\cal C}$.
\renewcommand{\toto}{lemma:total}
\end{proofL}


\begin{lemma}
\label{lemma:po}
The  total  order  $\rightarrow_S$   respects  the  process  order  between
transactions. 
\end{lemma}
\begin{proofL}
Consider two committed transactions $T$ and $T'$ issued by the same process, 
$T'$ being executed just after $T$. The variable $\mathit{window\_bottom}_{T'}$
of $T'$ is initialized at $\mathit{commit\_time}_T$ and can only increase
(during a $\sf read()$  operation at line \ref{BA08}, or during 
its $\sf try\_to\_commit()$ operation at line \ref{BA20}).
Because $\mathit{window\_bottom}_{T'} > \mathit{commit\_time}_{T}$ 
(line \ref{BA31}), we have $T \rightarrow_S T'$. By transitivity, 
this holds for all the transactions 
issued by a process.
\renewcommand{\toto}{lemma:po}
\end{proofL}

\begin{lemma}
\label{lemma:read-from}
$\forall T1, T2 \in \mathcal{C}: 
T1 \rf{} T2 \Rightarrow T1 \rightarrow_S T2$.
\end{lemma}
\begin{proofL}
Suppose that we have $T1 \rf{X} T2$ ($T2$ reads the value of $X$ written 
by $T1$.
After the read of $X$ by $T2$, $\mathit{window\_bottom}_{T2} \geq 
\mathit{commit\_time}_{T1}$ (line \ref{BA08}). 
We then have $T1 \rightarrow_S T2$.
\renewcommand{\toto}{lemma:read-from}
\end{proofL}

Because a transaction locks all the objects it accesses before committing 
(line \ref{BA27}),
we can order totally the committed transactions that access a given 
object $X$. Let $\lock{X}$ denote such a  total  order.

\begin{lemma}
\label{lemma:lock}
$X.{\sf write}_T()  \wedge X.{\sf write}_{T'}() 
 \wedge T \lock{X} T' \Rightarrow T \rightarrow_S T'$.
\end{lemma}
\begin{proofL}
W.l.o.g., consider that there is no transaction $T''$ such that 
$w_{T''}(X)$ and $T \rightarrow_S T'' \rightarrow_S T'$. 
Because $T \lock{X} T'$, when $T'$
executes line \ref{BA20}, 
$T$ has already updated 
$PT[x]$ and the corresponding $\mathit{CELL}(X)$ (because there is no $T''$,
at this time $PT[X] \downarrow = \mathit{CELL}(X)$). Because $X \in lws_{T'}$,
$\mathit{window\_bottom}_{T'} \geq (PT[X] \downarrow).\mathit{last\_read} 
\geq \mathit{commit\_time}_{T}$ (line \ref{BA20}). We then have 
$\mathit{commit\_time}_{T'} > \mathit{commit\_time}_{T}$ and thus
$T \rightarrow_S T'$.
\renewcommand{\toto}{lemma:lock}
\end{proofL}

\begin{corollary}
\label{coro:lock}
$X.{\sf write}_T()  \wedge X.{\sf write}_{T'}(X) 
\wedge T \rightarrow_S T' \Rightarrow T \lock{X} T'$.
\end{corollary}
\begin{proofC}
The corollary follows from the fact that $\rightarrow_S$ is a total order.
\renewcommand{\toto}{coro:lock}
\end{proofC}

\begin{lemma}
\label{lemma:legal}
$\forall T1, T2 \in \mathcal{C}, \forall X: (T1 \rf{X} T2)
\Rightarrow 
(\nexists T3: X.{\sf write}_{T3}() \wedge T1 
                           \rightarrow_S T3 \rightarrow_S T2$.
\end{lemma}
\begin{proofL}
By way of contradiction, suppose that such a $T3$ exists.
Again by way of contradiction, suppose that $T2 \lock{X} T1$. 
This is not possible
because $T2$ reads $X$ before committing, and $T1$ writes $X$ at 
the time of its commit
(line \ref{BA28}). Thus $T1 \rf{X} T2 \Rightarrow T1 \lock{X} T2$.

By Corollary \ref{coro:lock},
$X.{\sf write}_{T1}() \wedge X.{\sf write}_{T3}() \wedge T1 \rightarrow_S T3 
\Rightarrow T1 \lock{X} T3$.
We then have two possibilities: (1) $T3 \lock{X} T2$ and (2) 
$T2 \lock{X} T3$.

\begin{itemize}
\vspace{-0.2cm}
\item
Case  $T3 \lock{X} T2$. 
Let $lcell(X)$ be the local cell of $T2$ representing $X$.
When $T2$ executes line \ref{BA19}), $T3$ has already updated 
the field $end$ of the cell pointed by $lcell(X).\mathit{origin}$
with $\mathit{commit\_time}_{T3}$.
$T2$ will then update $\mathit{window\_top}_{T2}$ at a  smaller value
than $\mathit{commit\_time}_{T3}$,contradicting the original assumption  
$T3 \rightarrow_S T2$.
\vspace{-0.2cm}
\item
Case $T2 \lock{X} T3$.
When $T3$ executes line \ref{BA20}, $T2$ has already updated the field 
$\mathit{last\_read}$ of the cell pointed by $PT[X]$.
$T3$ will then update 
$\mathit{window\_bottom}_{T3}$ at a value greater than 
$\mathit{commit\_time}_{T2}$, contradicting the original assumption 
$T3 \rightarrow_S T2$, which completes the proof of the lemma.
\end{itemize}
%\vspace{-0.6cm}
\renewcommand{\toto}{lemma:legal}
\end{proofL}

%----------------------------------------------------------------------
\subsection{Proof that the causal past of each aborted transaction 
is serializable}

In order to show that, for each aborted transaction $T$, 
the partial order $\rightarrow_{PO}$ restricted to
$\mathit{past(T)}$ admits a legal linear extension, 
we have to show that there exists a total order $\rightarrow_T$ such that
the following properties hold:
\begin{enumerate}
\vspace{-0.2cm}
\item the order $\rightarrow_T$ is a total order,
\vspace{-0.2cm}
\item $\rightarrow_T$ respects the process order between transactions,
\vspace{-0.2cm}
\item $\forall T1, T2 \in \mathit{past(T)}: 
T1 \rf{} T2 \Rightarrow T1 \rightarrow_T T2$ and,
\vspace{-0.2cm}
\item $\forall T1, T2 \in \mathit{past(T)}, \forall X: (T1 \rf{X} T2)
\Rightarrow (\nexists T3 \in \mathit{past(T)}:
         X.{\sf write}_{T3}() \wedge T1 \rightarrow_T T3 \rightarrow_T T2$.
\end{enumerate}


\noindent
The order $\rightarrow_T$ is defined as follows:\\
(1) $\forall T1, T2 \in \mathit{past(T)} \setminus \{T\}:
     T1 \rightarrow_T T2$ if $T1 \rightarrow_S T2$ and,\\
(2) $\forall T' \in \mathit{past(T)} \setminus \{T\}:
T' \rightarrow_T T$.

\begin{lemma}
\label{lemma:total2}
The order $\rightarrow_T$ is a total order.
\end{lemma}
\begin{proofL}
 The proof follows directly from the  fact that  $\rightarrow_T$
is defined from the total order  $\rightarrow_S$ for the committed 
transactions in $\mathit{past(T)}$ (part 1 of its definition)
and the fact that all these transactions are defined as 
preceding $T$  (part 2 of its definition).


\renewcommand{\toto}{lemma:total2}
\end{proofL}

\begin{lemma}
\label{lemma:po2}
The total order $\rightarrow_T$ respects the process order between transactions.
\end{lemma}
\begin{proofL}
The proof follows from Lemma \ref{lemma:po} and the definition of 
$\rightarrow_T$.
\renewcommand{\toto}{lemma:po2}
\end{proofL}

\begin{lemma}
\label{lemma:read-from2}
$\forall T1, T2 \in \mathit{past(T)}: 
T1 \rf{} T2 \Rightarrow T1 \rightarrow_T T2$.
\end{lemma}
\begin{proofL}
Because no transaction can read a value from $T$, we necessarily have 
$T1 \neq T$.
When $T2 \neq T$, the proof follows from the definition of
$\rightarrow_T$ and Lemma \ref{lemma:read-from}. When $T2 = T$, 
the proof follows from directly from the definition of $\rightarrow_T$.
\renewcommand{\toto}{lemma:read-from2}
\end{proofL}

In the following lemma, we use the dual notion of the causal past of a 
transaction:  the {\it  causal future} of a transaction. 
Given a partial order  $\widehat{PO}$ defined on  a set of transactions, the 
causal future  of a  transaction $T$,  denoted $future(T)$,  is  the set
including $T$ and all the transactions $T'$  such that 
$T \rightarrow_\mathit{PO} T'$. The partial order  $\widehat{PO}$ used here 
is the  one defined in Section \ref{sec-transaction-histories}.


\begin{lemma}
\label{lemma:legal2}
$\forall T1, T2 \in \mathit{past(T)}: (T1 \rf{X} T2)
\Rightarrow (\nexists T3 \in \mathit{past(T)}: 
         X.{\sf write}_{T3}() \wedge T1 \rightarrow_T T3 \rightarrow_T T2$.
\end{lemma}
\begin{proofL}
For the same reasons as in Lemma \ref{lemma:read-from2}, we only need 
to consider the case when $T2 = T$.

By way of contradiction, suppose that such a transaction $T3$ exists.
Let it be the first such transaction to write $X$.
Let $T4$ be the transaction in $\mathit{future(T3)} \cap \{T'|T' \rf{} T\}$ 
that has the biggest $\mathit{commit\_time}$ value. $T4$ is well defined 
because otherwise, $T3$ wouldn't be in $\mathit{past(T)}$. 
Let $Y$ be the object written by $T4$ and read by $T$.

When $T$ reads $Y$ from $T4$, it updates $\mathit{window\_bottom}_T$ such that
$\mathit{window\_bottom}_T \geq \mathit{commit\_time}_{T4}$ (line \ref{BA08}).
From the fact that $T4 \in \mathit{future(T3)}$, we then have that 
$\mathit{window\_bottom}_T \geq \mathit{commit\_time}_{T3}$.


Either $T$ reads $Y$ from $T4$ and then reads $X$ from $T1$, or the opposite.
Let $\mathit{last\_op}$ be the latest of the two operations.
During $\mathit{last\_op}$, $T$ updates $\mathit{window\_bottom}_T$.
Due to the fact that $T3 \in \mathit{past(T)}$, $T3$ has already updated
the pointer $PT[Z]$ for some object $Z$ (line \ref{BA28}), and thus has already
updated the field $end$ (line \ref{BA23}) of the cell pointed by 
$lcell(X).\mathit{origin}$ ($lcell(X)$ being the local cell of $T$
representing $X$). $T$ will then observe 
$\mathit{window\_bottom}_T \geq \mathit{window\_top}_T$ (line \ref{BA11})
and will not complete $\mathit{last\_op}$, again a contradiction, 
which completes the proof of the lemma.
\renewcommand{\toto}{lemma:legal2}
\end{proofL}

%------------------------------------------------------------------
\subsubsection{VWC and read invisibility}
\begin{theorem}
\label{theo:vwc}
The algorithm presented in Figure \ref{fig:ttc-protocol}
satisfies  virtual world consistency and implements invisible 
read operations

\end{theorem}
\begin{proofT}
The proof that the algorithm presented in Figure \ref{fig:ttc-protocol}
satisfies  virtual world consistency
 follows from Lemmas \ref{lemma:total}, \ref{lemma:po}, 
\ref{lemma:read-from}, \ref{lemma:legal},
\ref{lemma:total2}, \ref{lemma:po2}, \ref{lemma:read-from2} and 
\ref{lemma:legal2}.


The fact that, for any shared object $X$ and any transaction $T$, 
the  operation $X.{\sf read}_T()$ is invisible follows  from 
a simple examination of the  text of the algorithm implementing that 
operation (lines \ref{BA01}-\ref{BA13} of Figure~\ref{fig:ttc-protocol}): 
there is no write into the shared memory.
\renewcommand{\toto}{theo:vwc}
\end{proofT}


%=========================================================




%===========================================================================
\subsection{Step 2: adding probabilistic permissiveness to the  protocol}
\label{sec:algorithm-V2} 
\label{sec:algo-V2-permissiveness}

This section  presents the final IR\_VWC\_P protocol that  ensures virtual
world  consistency, read  invisibility and   probabilistic permissiveness. 
The   first part describes  the protocol  while the  second part  proves 
its correctness. 



%\vspace{-0.1cm}
\subsubsection{The IR\_VWC\_P protocol}
%\vspace{-0.2cm}
To   obtain   a  protocol   that   additionally  satisfies    probabilistic
permissiveness,  only  the operation ${\sf try\_to\_commit}_T()$  has to be
modified.  
The algorithms implementing the operations ${\sf begin}_T()$, 
$X.{\sf read}_T()$ and  $X.{\sf write}_T()$  are exactly the same as  
the ones described in Figure \ref{fig:ttc-protocol}. 
The  algorithm implementing  the new version of the operation 
${\sf try\_to\_commit}_T()$ is described in Figure~\ref{fig:ttc-V22-protocol}. 
As we are about to see, it is not a new protocol but an appropriate
enrichment of the previous ${\sf try\_to\_commit}_T()$ protocol. 

%---------------------------------------------------------------
\begin{figure}[ht!]
\centering
\scalebox{0.35}{\input{VWC-comp/figures/fig-intervals.pdf_t}}
%\scalebox{0.4}{\input{fig-intervals.pstex_t}}
\caption{Commit intervals}
\label{fig:intervals}
\end{figure}
%---------------------------------------------------------------
    


\paragraph{A set of intervals for each transaction}
Let us consider the execution depicted in Figure \ref{fig:intervals}
made up of three transactions: $T1$ that writes $X$, $T2$ that reads $X$ 
and obtains the value written by $T1$, and  $T3$ that writes $X$. 
When we consider the base protocol described in Figure 
\ref{fig:ttc-protocol}, the commit window of $T3$ is 
$]commit\_time_{T2}..+\infty[$. 
As the aim is  not to abort a transaction if it can be appropriately 
serialized, it is easy to see  that associating  this window to $T3$ is not
the best  choice that can be done.  Actually $T3$ can be  serialized at any
point of the commit line as long as the  read of $X$ by $Y
2$ remains
valid. This  means that the  commit point of  $T3$ can be 
any point in $]0..commit\_time_{T1}[ ~\cup~]commit\_time_{T2}..+\infty[$.

This simple example shows that,  if one wants to ensure probabilistic 
permissiveness,   the notion of  continuous commit  window  of a transaction
is a too restrictive notion.  It has  to be replaced  by  a set  of time
intervals  in order valid commit times not to be a priori eliminated from 
random choices.  



\paragraph{Additional  local variables}
According to the  previous discussion, two new variables  are introduced at
each process $p_i$.  
The set   $\mathit{commit\_set}_T$ is  used to contain  the  intervals
in which  $T$ will be allowed to  commit. To  compute  its   final  value,  
the  set $\mathit{forbid}_T$ is used to store  the windows in which $T$ 
cannot be committed.  


\paragraph{The enriched ${\sf try\_to\_commit}_T()$ operation}
The new  ${\sf try\_to\_commit}_T()$ algorithm
is described in Figure~\ref{fig:ttc-V22-protocol}.
In a very interesting way, this  ${\sf try\_to\_commit}_T()$ 
algorithm has the same structure as the one described in  
Figure \ref{fig:ttc-protocol}. The lines with the same number are 
identical in both algorithms, while the number of the lines of 
Figure \ref{fig:ttc-protocol} that are modified are postfixed by a letter. 
The new/modified  parts are the followings. 



%==================================================================
\begin{figure}[htb!]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
%\resetline
\begin{tabbing}
aaaaaaa\=aa\=aaaaa\=aa\=\kill %~\\

{\bf operation} ${\sf try\_to\_commit}_T()$: \\

(\ref{BA18}) \> lock all the objects in $lrs_T \cup lws_T$; \\

(\ref{BA19}) \> {\bf for each} $(Y \in lrs_T)$ {\bf do} 
    $window\_top_T \leftarrow 
     \min\big(window\_top_T,
     (lcell(Y).origin\downarrow).\mathit{end} \big)$ {\bf end for};\\

(\ref{BA20}.A) \> $\mathit{commit\_set}_T 
 \leftarrow \{~ ]\mathit{window\_bottom}_T, \mathit{window\_top}_T[~\}$;\\

(\ref{BA20}.B) \> {\bf for each} $(X \in lws_T)$ {\bf do}\\

(\ref{BA20}.C) \> \> $x\_ptr \leftarrow PT[X]$;
                     $\mathit{x\_forbid_T}[X] \leftarrow \emptyset$;\\

(\ref{BA20}.D) \> \> 
{\bf while} $((x\_ptr \downarrow).\mathit{last\_read} 
                > \mathit{window\_bottom}_T)$ {\bf do}\\

(\ref{BA20}.E) \> \> \> 
$\mathit{x\_forbid_T}[X] \leftarrow \mathit{x\_forbid_T}[X] \cup 
      \{~ [(x\_ptr \downarrow).\mathit{begin},
                   (x\_ptr \downarrow).\mathit{last\_read}]~ \}$;\\

(\ref{BA20}.F) \> \> \> $x\_ptr \leftarrow (x\_ptr \downarrow).prev$\\

(\ref{BA20}.G) \> \> {\bf end while}\\

(\ref{BA20}.H)  \> {\bf end for};\\

(\ref{BA20}.I) \> 
 $\mathit{commit\_set}_T  \leftarrow \mathit{commit\_set}_T \backslash 
              \bigcup_{X\in lws_T}\big(\mathit{x\_forbid_T}[X]\big)$;\\


(\ref{BA21}.A) \> {\bf if} $(\mathit{commit\_set}_T = \emptyset)$ {\bf then}
      release all locks and disallocate all local cells; 		
      ${\sf return}(abort)$ {\bf end if};\\

(\ref{BA22}.A) \> $commit\_time_T \leftarrow$ 
         select a (random/heuristic) time value
         $\in ~\mathit{commit\_set}_T$; \\

(\ref{BA23}.A) \> {\bf for each} $(X \in lws_T)$ {\bf do} \\

(\ref{BA23}.B) \> \> $x\_ptr \leftarrow PT[X]$;\\

(\ref{BA23}.C) \> \> 
   {\bf while} $((x\_ptr \downarrow).\mathit{begin} > 
        \mathit{commit\_time}_T)$ {\bf do} 
        $x\_ptr \leftarrow (x\_ptr \downarrow).prev$ {\bf end while};\\

(\ref{BA23}.D) \> \> $(x\_ptr \downarrow).\mathit{end} \leftarrow 
    \min((x\_ptr \downarrow).\mathit{end},\mathit{commit\_time}_T)$\\

(\ref{BA23}.E) \> {\bf end for};\\


(\ref{BA24}.A) \> {\bf for each} $(X \in lws_T)$ 
   {\bf such that} $(\mathit{commit\_time}_T > 
       (PT[X] \downarrow).\mathit{begin})$ {\bf do}\\

(\ref{BA25}) \>\> \> 
       allocate in shared memory  a new cell for $X$ denoted $CELL(X)$; \\

(\ref{BA26}) \>\>\>  $CELL(X).value \gets lcell(X).value$;
                  $CELL(X).last\_read \gets commit\_time_T$;\\

(\ref{BA27}) \>\>\>  $CELL(X).begin \gets commit\_time_T$; 
                     $CELL(X).end \leftarrow +\infty$; \\

(\ref{BA28}.A) \>\>\>   $CELL(X).prev  \leftarrow PT[X]$;
                        $PT[X]  \leftarrow  ~ \uparrow CELL(X)$\\

(\ref{BA29}.A) \> {\bf end for};\\

(\ref{BA30}) \> {\bf for each} $(X \in lrs_T)$ {\bf do} \\


(\ref{BA31}) \>\>
   $(lcell(X).origin \downarrow).last\_read \leftarrow 
     \max((lcell(X).origin \downarrow).last\_read, commit\_time_T)$ \\

(\ref{BA32}) \> {\bf end for};\\

(\ref{BA33}) \> release all locks and disallocate all  local cells; 
               $last\_commit_i \leftarrow commit\_time_T$;\\
	
(\ref{BA34}) \> ${\sf return}(commit)$. \\

{\bf end operation}.
% \\

\end{tabbing}
\normalsize
\end{minipage}
}
\caption{Algorithm for the ${\sf try\_to\_commit()}$ operation of 
         the permissive protocol}
\label{fig:ttc-V22-protocol}
}
\end{figure}
 
\begin{itemize}
%
\vspace{-0.2cm}
\item  Lines \ref{BA20}.A-\ref{BA20}.I  replace  line 
\ref{BA20} of Figure~\ref{fig:ttc-protocol} that was computing the value of 
$\mathit{window\_bottom}_T$.
%
These new lines compute instead the set of intervals that  
constitute  $\mathit{commit\_set}_T$. To that end they suppress 
from the initial interval 
$]\mathit{window\_bottom}_T, \mathit{window\_top}_T[$, 
all the time intervals that would invalidate values read by committed 
transactions.  This is done for each object $X\in lws_T$
(line~\ref{BA20}.H; see section~\ref{sec:appendix-forbid} for an example). 
If  $\mathit{commit\_set}_T$ is empty, the transaction $T$ is  aborted
(line  \ref{BA21}.A).
%
\vspace{-0.2cm}
\item The commit time of a transaction $T$ is now selected from 
the intervals in  $\mathit{commit\_set}_T$ (line  \ref{BA22}.A).
%
\vspace{-0.2cm}
\item
Line \ref{BA23} of Figure~\ref{fig:ttc-protocol}
was assigning, for each $X\in lws_T$, its value to  $(PT[X]\downarrow).end$, 
namely the value $\mathit{commit\_time}_T$. 
%
This is now done by the new lines  \ref{BA23}.A-\ref{BA23}.E.
Starting from  $PT[X]$, these statements use the pointer $prev$ to find the 
cell (let us denote it say $CX$)  of  the list implementing $X$ whose field  
$CX.end$ has to be assigned the value $\mathit{commit\_time}_T$. 
Let us remember that $CX.end$ 
defines the end of the lifetime of the value kept in $CX.value$. 
This cell  $CX$ is the first cell (starting from  $PT[X]$) such that 
$CX.begin < \mathit{commit\_time}_T$. 
%
\vspace{-0.2cm}
\item Line \ref{BA24} of Figure~\ref{fig:ttc-protocol} 
assigned its new value to every object $X\in lws_T$. 
%
Now such an  object $X$  has  to be assigned its new value  only if 
$\mathit{commit\_time}_T > (PT[X] \downarrow).\mathit{begin}$. 
This is because when 
$ \mathit{commit\_time}_T  < (PT[X] \downarrow).\mathit{begin}$,  
the value  $v$ to be written  is not the last one according to the
serialization order. Let us remember that the serialization order, that 
is   defined by commit times, is  not required to be real time-compliant
(which would be required if we wanted to have linearizability instead of 
serializability, see Section \ref{sec:from-ser-to-lin}). 
An example is given in section \ref{sec:appendix-example-for-ct}. 
%
Finally, the  pointer $prev$  is appropriately updated (line \ref{BA28}.A).
(Starting from $(PT[X]\downarrow).next$,  these pointers allows  for the 
traversal of the list implementing $X$.) 
\end{itemize}




%=================================================================
\subsubsection{Substraction on sets of  intervals (line \ref{BA20}.H of 
Figure~\ref{fig:ttc-V22-protocol})}
\label{sec:appendix-forbid}

The subtraction  operation on sets of intervals of real numbers 
$\mathit{commit\_set}_T \backslash \mathit{x\_forbid_T}[X]$ 
has the usual meaning, which is explained with an example in Figure 
\ref{fig:substraction-on-intervals}.

%---------------------------------------------------------------
\begin{figure}[ht]
\centering
\scalebox{0.35}{\input{VWC-comp/figures/fig-intervals-forbidden.pdf_t}}
\caption{Subtraction on sets of intervals}
\label{fig:substraction-on-intervals}
\end{figure}
%---------------------------------------------------------------

The top line represents the value of $commit\_time_T$  that is made 
up of 4 intervals, $commit\_time_T= \{~]a..b[,~]c..d[,~]e..f[, ~]g..h[~\}$. 
The  black intervals  denote  the time  intervals  in which  $T$ cannot  be
committed.  The set  $x\_forbid_T[X]$ is the set of  intervals in which $T$
cannot commit due  to the access to $X$ issued by $T$ and other transactions. 
This set  is depicted in the second line of the  
where we have  $x\_forbid_T[X]=  \{~[0..a'],~[b'..c'],[d'..+\infty[~\}$.
%
The last line of the figure, show that we  have 
 $commit\_time_T \backslash  x\_forbid_T[X]
                       = \{~]a'..b[,~]c..b'[, ~]g..d'[~\}$. 





%=================================================================
\subsubsection{About the predicate of line \ref{BA24}.A 
of Figure~\ref{fig:ttc-V22-protocol}}
\label{sec:appendix-example-for-ct} 

This section explains the  meaning of the predicate used at line \ref{BA24}.A: 
$\mathit{commit\_time}_T > (PT[X] \downarrow).\mathit{begin}$. 
This predicate controls the physical write in a  shared memory cell
of the  value $v$ that $T$ wants to write into $X$
(meaning that not every item in a transactions write set will
be phyiscally written to memory). 
It states that the value is written only if 
$\mathit{commit\_time}_T > (PT[X] \downarrow).\mathit{begin}$. 
This is due to the following reason. 

%------------------------------------------------------------
\begin{figure}[ht]
\centering
\scalebox{0.35}{\input{VWC-comp/figures/fig-constraint-commit-time.pdf_t}}
\caption{Predicate of line~\ref{BA24}.A of Figure~\ref{fig:ttc-V22-protocol}}
\label{fig:predicate-line-BA24A}
\end{figure}
%---------------------------------------------------------------



Let us remember that a transaction is serialized at a random point that 
belongs to its current set of intervals $current\_set_T$. Moreover as 
we are looking for serializable transactions, the serialization points 
of two transactions $T1$ and $T2$ are not necessarily real time-compliant, 
they depend only of their sets $current\_set_{T1}$ and $current\_set_{T1}$,
respectively. 

 
An example is described in Figure~\ref{fig:predicate-line-BA24A}.
Transaction $T1$, that invokes $X.{\sf write}_{T1}()$,  
executes first (in real time), commits and  is serialized 
at (logical) time $commit\_time_{T1}$ as indicated on the
Figure. 
Then  (according to real time) transaction $T2$, that invokes 
also $X.{\sf write}_{T2}()$,   is invoked and then commits. 
Moreover, its commit set and the random selection of its commit time 
are such that  $commit\_time_{T2} <commit\_time_{T1}$. It follows 
that $T2$ is serialized before $T1$. 
Consequently, the last value of $X$ (according to commit times) 
is the one written by $T1$, that has overwritten the one written by $T2$. 
The predicate $\mathit{commit\_time}_T > (PT[X] \downarrow).\mathit{begin}$
prevents the committed transaction $T2$ to write its value into $X$ 
in order write and  read operations on $X$ issued by other transactions 
be in agreement with the serialization order defined  by commit times. 

%=================================================================




%--------------------------------------------------------------------------

%===================================================
\subsection{Proof of the probabilistic permissiveness property}
\label{sec:proof-proba}

In order  to show  that the protocol  is probabilistically  permissive with
respect to virtual world consistency, we have to show the following. 
Given a  transaction history that contains only committed transactions,
if the partial order $\widehat{PO} = (PO,\rightarrow_{PO})$ accepts a legal
linear extension  
(as defined in Section \ref{sec:opacity-and-VWC}),  
then the history is accepted 
(no operation returns abort) with positive probability.
As in \cite{GHS08}, we consider that operations are executed in isolation. 
It is important to notice here that only operations,  
not transactions, are isolated. 
Different transactions can still be interlaced.

Let $\rightarrow_{S}$ be the order on transactions defined by the protocol
according to the $\mathit{commit\_time}_T$ variable of each transaction $T$
(this order has already been defined in Section \ref{sec:algorithm-V1-proof}).

\begin{lemma}
\label{lemma:proba-order}
Let $T$ and $T'$ be two committed transactions 
such that $T \not\rightarrow_{PO} T'$ and
$T' \not\rightarrow_{PO} T$. If there is a legal linear extension of 
$\widehat{PO}$ in which $T$ precedes $T'$, then
there is a positive probability that $T \rightarrow_S T'$.
\end{lemma}
\begin{proofL}
Because $T \not\rightarrow_{PO} T'$,
the set $past(T) \backslash past(T')$ is not empty
($past(T)$ does not contain $T'$).
% and
%$T' \not\rightarrow_{PO} T$, both sets $past(T) \backslash past(T')$ and
%$past(T') \backslash past(T)$ are not empty ($past(T)$ does not contain
%$T'$ and $past(T')$ does not contain $T$).
Let    $biggest\_ct_{T,T'}$     be    the    biggest     value    of    the
$\mathit{commit\_time}$ variables (chosen at line \ref{BA22}.A) of the  
transactions in the set $past(T) \cap past(T')$ if it is not empty, or $0$ 
otherwise. Suppose that every transaction in $past(T) \backslash past(T')$ 
chooses the smallest value possible for its $\mathit{commit\_time}$ 
variable.
These values cannot be  constrained (for their lower bound) 
 by a value bigger than $biggest\_ct_{T,T'}$, 
thus they can all be smaller
than $biggest\_ct_{T,T'} + \epsilon$ for any given $\epsilon$.

Suppose now  that $T'$
%every transaction in $past(T') \backslash past(T)$ 
chooses a  value bigger than $biggest\_ct_{T,T'} + \epsilon$ for its 
$\mathit{commit\_time}$ variable.
This is possible because, for a given transaction $T1$, 
the upper bound on 
the value of $\mathit{commit\_time}_{T1}$ can only be fixed by 
a transaction $T2$ that overwrites 
a value read by $T1$ (lines \ref{BA10} and \ref{BA19}).
Suppose now that $T1$ is $T'$.
%a transaction in $past(T') \backslash past(T)$.
If there was such a transaction $T2$ in $past(T)$, 
then there would be no legal linear extension of 
$\rightarrow_{PO}$ in which $T$ precedes $T'$. 
Thus if there is a legal linear extension of 
$\rightarrow_{PO}$ in which $T$ precedes $T'$, then
there is a positive probability that $T \rightarrow_S T'$.
\renewcommand{\toto}{lemma:proba-order}
\end{proofL}


  

\begin{lemma}
\label{lemma:proba-succeed}
Let $\widehat{PO} = (PO,\rightarrow_{PO})$ be a partial order that
accepts a legal linear extension. Every operation   
of each transaction in $PO$
does not return $abort$ with positive probability. 
\end{lemma}
\begin{proofL}
$X.{\sf write}_T()$  operations cannot return $abort$. Therefore,  
we  will  only  consider   the  operations  $X.{\sf  read}_T()$   and  ${\sf
try\_to\_commit}_T()$.

Let $\rightarrow_{legal}$ be a legal linear extension of $\rightarrow_{PO}$.
Let $\sf op$ be an operation executed by a transaction.
Let $\mathcal{C}_{op}$ be the set of transactions that have ended their 
$\sf try\_to\_commit()$ 
operation before operation $\sf op$ is executed (because we consider 
that the operations
are executed in isolation, this set is well defined).  Let $\rightarrow_{op}$
be the total order on these transactions defined by the protocol.

From Lemma \ref{lemma:proba-order}, 
two transactions that are not causally related can be totally ordered in any 
way that allows a legal linear extension of $\rightarrow_{PO}$.
There is then  a positive probability that 
 $\rightarrow_{op}~ \subset ~\rightarrow_{legal}$.
Suppose that it is true. Let $T$ be the transaction executing $\sf op$.
Let $T1$ and $T2$ be the transactions directly preceding and following $T$ 
in $\rightarrow_{legal}$ restricted to $\mathcal{C}_{op} \cup \{T\}$ 
if they exist.
If $T1$ does not exist, then $window\_bottom_T = 0$ at the time of all the 
operation of $T$, and thus $T$ can execute successfully all its operations.
Similarly, if $T2$ does not exist, then $window\_top_T = +\infty$ 
at the time of all the 
operation of $T$, and thus $T$ can execute successfully all its operations.
We will then consider that both $T1$ and $T2$ exist.


Because $\rightarrow_{legal}$ is a legal linear extension of 
$\rightarrow_{PO}$, any transaction from which $T$ reads a value is 
either $T1$ or a transaction preceding $T1$ in 
$\rightarrow_{op}$ (line \ref{BA08})
resulting in a value for $window\_bottom_T$ that is at most $commit\_time_{T1}$. 
Similarly, any transaction that 
overwrote a value  read by $T$
at the time of $\sf op$ is either $T2$ or a transaction following 
$T2$ in $\rightarrow_{op}$ (line \ref{BA10})
resulting in a value for $window\_top_T$ that is at least $commit\_time_{T2}$. 
All the read operations 
of $T$ will then succeed (line \ref{BA11}).

Let us now consider the case of the $\sf try\_to\_commit()$ operation.
Because all read operations have succeeded, 
the  set  $\mathit{commit\_set}_T  =  ~]window\_bottom_T.. window\_top_T[$
(line \ref{BA20}.A)  is not empty
and must contain the set $~]commit\_time_{T1}.. commit\_time_{T2}[$.
Because   $\rightarrow_{legal}$   is    a   legal   linear   extension   of
$\rightarrow_{PO}$, if $T$ writes to an object $X$ then $T$
 cannot be  placed between two transactions $T3$ and
$T4$ such that $T3$ reads a value of object $X$  written by $T4$. 
 
Because  these intervals  (represented by  $\mathit{x\_forbid_T}[X]$, lines
\ref{BA20}.B to \ref{BA20}.H)
are the only ones removed from $\mathit{commit\_set}_T$ (line \ref{BA20}.I)
and because there is  a legal linear extension of 
$\rightarrow_{PO}$ which includes $T$,
 $\mathit{commit\_set}_T$  is  not empty  and  the  transaction can  commit
successfully,   which ends the proof of the lemma.
\renewcommand{\toto}{lemma:proba-succeed}
\end{proofL}


\begin{theorem}
\label{theo:permissive}
The algorithm presented in Figure \ref{fig:ttc-protocol}, where the 
$\sf try\_to\_commit()$ operation has been replaced by the one presented in 
Figure \ref{fig:ttc-V22-protocol}, is probabilistically permissive 
with respect to virtual world consistency.
\end{theorem}
\begin{proofT}
From Lemma \ref{lemma:proba-succeed}, all transactions of a history can commit 
with positive probability if the history is virtual world consistent, which 
proves the theorem.
\renewcommand{\toto}{theo:permissive}
\end{proofT}




%-------------------------------------------------------------------------
\subsection{Garbage collecting  useless cells} 
\label{sec:garbage-collection}


This section presents a relatively simple mechanism that allows  shared memory 
cells that have become inaccessible to be collected for  recycling. 
This  mechanism is  based on  the  pointers $next$,  two additional  shared
arrays, the addition  of new statements to both  $X.{\sf read}_T()$ and the
${\sf try\_to\_commit}_T()$,  and a background task $BT$. 


\paragraph{Additional arrays}
The first is an array of atomic 
variables denoted $\mathit{LAST\_COMMIT}[1..m]$ 
(remember that $m$ is the number of sacred objects).  This array 
is such that  $\mathit{LAST\_COMMIT}[X]$ (which is initialed to $0$) 
contains the date of the last  committed transaction that has written into $X$.
Hence, the  statement ``$\mathit{LAST\_COMMIT}[X] \leftarrow commit\_time_T$''
is added in the {\bf do} ... {\bf end} part of line \ref{BA23}. 


The second  array, denoted  $\mathit{MIN\_READ}[1..n]$, is  
made up of one-writer/one-reader atomic registers 
(let us recall that $n$ is the total number of processes).
$\mathit{MIN\_READ}[i]$ is written by $p_i$ only and read by the 
background task $BT$ only.  It is initialized to $+\infty$ and reset to its 
initial value value when $p_i$ terminates  ${\sf try\_to\_commit}_T()$
(i.e., just before returning at line \ref{BA21} or line  \ref{BA34} 
of Figure~\ref{fig:ttc-protocol}). 
When $\mathit{MIN\_READ}[i]\neq +\infty$, its value is  the smallest commit 
date of a value read by the transaction $T$ currently executed by $p_i$. 
%
Moreover, the following statement has to be added after line \ref{BA03}
of the  $X.{\sf read}_T()$ operation:\\
\centerline{$\mathit{MIN\_READ}[i] \leftarrow 
             \min(\mathit{MIN\_READ}[i],\mathit{LAST\_COMMIT}[X]).$}


\paragraph{Managing the {\it next} pointers}
When   a  process  executes  the  operation  ${\sf try\_to\_commit}_T()$   
and commits the corresponding transaction  $T$, it has to update a  
pointer $next$ in order to  establish a correct linking  of the  cells  
implementing  $X$.  To that end,  $p_i$  has to execute 
$(PT[X]\downarrow).next\leftarrow \uparrow CELL[X]$ 
just before updating  $PT[X]$ at line \ref{BA28}. 





\paragraph{The background task $BT$}
This sequential task, denoted $BT$, is described in 
Figure~\ref{fig:background-task}. It uses a local array denoted  
$last_valid\_pt[1..m]$   such that $last\_valid\_pt[X]$ is a pointer 
initialized   to  $PT[X]$ (line \ref{BT45}). 
Then its value is a  pointer to the cell containing the 
oldest value of $X$ that is currently accessed by a transaction
(this is actually a  conservative value). 


%==================================================================
\begin{figure}[htb]
\centering{ \fbox{
\begin{minipage}[t]{150mm}
\footnotesize 
\renewcommand{\baselinestretch}{2.5} 
\resetline
\begin{tabbing}
aaaaaaaa\=aaaa\=aaaaa\=aa\=\kill %~\\

\line{BT45} \> {\bf init: for every} $X$ {\bf do} 
                $last\_valid\_pt[X]  \leftarrow  PT[X]$ {\bf end for}.\\  ~\\


{\bf background task} $BT$: \\


\line{BT46} \> {\bf repeat forever}\\

\line{BT47} \>\> $\mathit{min\_useful} \leftarrow 
                 \min(\{\mathit{MIN\_READ}[i]\}_{1\leq i \leq n})$;\\

\line{BT48} \>\> {\bf for every}  $X$ {\bf do} \\


\line{BT49} \>\>\> $last \leftarrow last\_valid\_pt[X]$;\\

\line{BT50} \>\>\> {\bf while} 
       $\big((last \neq PT[X])\wedge  (last\downarrow).next\downarrow).next
       \neq \bot) $\\ 

\line{BT51} \>\>\>  $~$  $~$ $~$  $~$ $~$ $~$ 
        $\wedge   
      [(((last\downarrow).next\downarrow).next \downarrow).commit\_time 
                                         < \mathit{min\_useful}]\big)$\\


\line{BT52} \>\>\>\> {\bf do} $temp\leftarrow last$; 
                              $last\leftarrow (last\downarrow).next$; 
                              release the cell pointed to by $temp$\\



\line{BT53} \>\>\> {\bf end while};\\

\line{BT54} \>\>\> $last\_valid\_pt[X] \leftarrow last$\\

\line{BT55} \>\> {\bf end for}\\ 

\line{BT56} \> {\bf end repeat}.
\end{tabbing}
\normalsize 
\end{minipage}
}
\caption{The cleaning background task $BT$}
\label{fig:background-task}
}
\end{figure}
%=================================================================

The body of task $BT$ is an infinite loop (lines \ref{BT46}-\ref{BT56}). 
$BT$ first computes the smallest commit date still useful (line \ref{BT47}). 
Then, for every shared object $X$, $BT$ 
scans the list from $last\_valid\_pt[X]$ 
and releases the space occupied by all the cells containing 
values of $X$ that are no longer accessible (lines \ref{BT50}-\ref{BT53}), 
after which it  updates  $last\_valid\_pt[X]$ to its new pointer value
(line \ref{BT54}).  Lines \ref{BT50} and  \ref{BT51}
uses two consecutive $next$ pointers.  
Those  are   due  to  the   maximal  concurrency  allowed by the algorithm,
more specifically,   they  prevent an  $X.{\sf read}_T()$ operation from 
accessing a released cell.     


It is worth noticing that the STM system and task  $BT$ can run 
concurrently without mutual  exclusion. Hence, $BT$  allows for 
maximal concurrency.  The  reader can also observe that such a maximal 
concurrency has a price, namely (as  seen in line \ref{BT50} where the last
two cells with commit time smaller than $\mathit{min\_useful}$ are kept)
for any shared object $X$, task $BT$ allows all -but at most one-  useless
cells to be released.  





%---------------------------------------------------------------------------
\subsection{From serializability to linearizability}
\label{sec:from-ser-to-lin}
The  IR\_VWC\_P protocol guarantees  that the committed transactions  are
serializable.   A simple modification of the protocol allows it to 
ensures the  stronger ``linearizability'' condition \cite{HW90} instead of 
the weaker  ``serializability''condition.  
The modification  assumes a common  global clock  that processes can read by
invoking  the operation ${\sf System.get\_time}()$. It is as follows. 
\begin{itemize}
\vspace{-0.2cm}
\item 
The statement  $window\_bottom_T \gets last\_commit_i$ 
at   line \ref{BA01} of  ${\sf begin}_T()$ is replaced by the statement 
 $window\_bottom_T \gets {\sf System.get\_time}()$. 
%     
\vspace{-0.2cm}
\item 
The following statement is added just between  line \ref{BA19} and line
 \ref{BA20}  of  ${\sf try\_to\_commit}_T()$ (Figure~\ref{fig:ttc-protocol}):\\
\centerline{{\bf if} $(window\_top_T = +\infty)$ {\bf then}
	      $window\_top_T \gets {\sf System.get\_time}()$ {\bf end if}.}

\end{itemize}
It is easy to see that these modifications force the  commit time of a 
transaction to  lie   between  its starting  time and its end time. 
Let us  observe that  now the disjoint access  parallelism property  
remains to be  satisfied  except for  the accesses to the common clock. 


\subsection{Some additional interesting properties}

% \anote{NEED TO INTRO/UPDATE THIS SECTION or maybe should just remove it}
This chapter has focused on the STM properties of permissiveness, virtual world consistency,
and invisible reads, but,
interestingly enough, this  STM protocol  satisfies several additional  noteworthy
features/properties described in the following paragraphs. 
By satisfying these additional properties we then know that they are compatible
with permissiveness, virtual world consistency, and invisible reads.
Additionally, it is important to realize that some of these additional properties are not necessarily
exclusive to STM systems and may be applicable to other concurrent algorithms,
or even algorithms in general.
Following this, we must acknowledge that there are nearly countless properties
to consider (STM specific properties, concurrent algorithm specific properties, or even properties applicable
generally to algorithms) whose
compatibility with other properties might be examined when taking TM into account.
Given such a huge space of options to examine, the community
is given the task of deciding which properties and their combinations might be important and
others that might not.
Unfortunately this is not always a straightforward task, especially given
that we do not know to what extent and for what tasks transactional memory
might be used for in the future.

In any case this thesis suggests studying these properties should be done while still considering
a consistency condition such as opacity
or virtual world consistency, keeping in the spirit of our high level Definition \ref{def:trans-def}
or a transaction.
While there might be other interesting properties to study when considering
weaker definitions of transactions and consistency, when doing this the goal of ease of use
is partially lost and is therefore not examined in this thesis.
The following are some properties satisfied by the protocol discussed in this chapter which appear
to be important when considering efficient STM protocols.

\paragraph{Base operations and underlying locks}
The use of expensive  base synchronization operations such as 
${\sf Compare\&Swap()}$  or  the use of underlying locks are very
powerful and allow us to implement interesting concurrent algorithms.
Unfortunately these operations can be quite expensive and their use in
an STM system can cause inefficiencies  and prevent scalability
especially when compared to just using simple reads and writes.
Hence, an STM systems should use  synchronization operations 
sparingly  (or even not at all) and the use of locks should be  as
restricted as  possible. 
Following this, the protocol described in this chapter uses only base read/write operations and a lock per object 
that is  used   at  commit  time   only (no synchronization operations
are used in the transactional read and write operations).


\paragraph{Disjoint access parallelism}
Ideally, an  STM system should allow transactions that are on distinct 
objects to execute without interference, i.e., without accessing the same
base shared variables.
Any concurrent protocol that satisfies \emph{disjoint access parallelism} ensures that
non-conflicting operations do not access the same shared data.
At first glance this seems like an essential and straightforward property to ensure, but due to the
fact that the locations a transaction might access are not known until they actually happen,
it can be difficult to design safe and efficient disjoint access parallel STM protocols.
Still, this is a nice property for an STM system to implement for several reasons.
First is scalability, a program using STM for synchronization that is written so that each process shares
very little data with other processes could have its scalability limited by the sharing of data within
the STM implementation.
Second is simply efficiency, simply because shared data can be expensive to access
(especially that which is highly contended).
Additionally, when specifically considering TM, this property helps avoid unnecessary aborts that my be caused by accessing
shared memory that would not otherwise cause conflicts, such as relying on a global counter for validation.


\paragraph{Multi-versioning}
The  proposed IR\_VWC\_P  protocol  uses multiple  versions 
of each  shared object $\ms{X}$ (kept in a list).
Keeping multiple versions of an object does not change they way the programmer
uses transactions, but instead they can be used by the STM protocol to
do some interesting things.
For example, specific to the protocol in this chapter, keeping multiple
versions allows the protocol to have a larger time  line to find valid locations
to serialize transactions.
In fact, the amount of versions kept is at least enough to ensure that any
live transaction can be serialized at any valid time starting from the
time the previous transaction was committed by this thread
(necessary for permissiveness).

This work is not the first to consider multi-versioning for STM systems, in fact
such systems
have  been  proposed  several years ago \cite{CR06} and have recently received a new interest, e.g., 
\cite{AH11,PFK10} for studying permissiveness.
Differently than the work presented in this chapter, these papers 
do not consider virtual wold consistency  as a  consistency condition and,
in addition, the papers \cite{AH11,PFK10} consider a different  notion of permissiveness
called multi-version permissiveness that states that read-only 
transactions are never aborted  and   an update transaction  can be aborted
only  when in conflict with other transactions writing the same objects.
More specifically, paper 
\cite{PFK10} studies inherent properties of STMs that use multiple 
versions    to   guarantee    successful   commits    of    all   read-only
transactions. This paper presents also a  protocol with visible read 
operations that   recovers useless versions. Paper
\cite{AH11} shows that  multi-version permissiveness can be obtained from 
single-version. The STM   protocol it presents satisfies 
the disjoint access parallelism property,  requires visible read operations
and uses $k$-Compare\&single-swap operations. 

\paragraph{Trade-offs}
Unfortunately a change in one part of the system, by for example ensuring some new property
or making a change for efficiency, almost always implies an
impact on another part of the system.
Due to this, a discussion of properties
would not be complete without also examining their trade offs.
For example a global counter may violate disjoint access parallelism, but it can
also be used to avoid the location-by-location revalidation of a transaction's read set every time a new read
is performed (efficient state of the art STM algorithms such as TL2 \cite{DSS06} use
such a technique).
Or, for example, multi-versioning requires additional memory space and brings up additional
challenges such as how many versions to keep and how to clean up old versions.
Given this, it is extremely difficult to choose the ``best'' properties for an STM system that works
across all workloads and consequently encourages the study of various properties in different
combinations across various workloads.
As interesting example of this can be found in \cite{DH12} where shorter transactions are treated
differently than longer ones.

% % % % % % \section{Improving the  base protocol described in Figure 
% % % % % % \ref{fig:ttc-protocol}}
% % % % % % \label{sec:improving-base-protocol}
% % % % % % 
% % % % % % The previous sections investigated the interactions between a few different STM
% % % % % % properties and consistency conditions.
% % % % % % It showed that permissiveness, opacity, and invisible reads are incompatible, but
% % % % % % if opacity is switched for virtual world consistency then not only are the properties
% % % % % % compatible, they can be satisfied by a realistic protocol.
% % % % % % This work focused mostly on theory, showing
% % % % % % concepts to be possible or not.
% % % % % % This study of theory is important as it gives us a starting point from where to design
% % % % % % practical STM algorithms, but
% % % % % % does not provide a complete examination of STM
% % % % % % as it leaves us with no practical implementations.
% % % % % % 
% % % % % % This section begins an investigation towards this more practical study of algorithms.
% % % % % % What we have observed is that in practice we might not want a perfectly permissive algorithm
% % % % % % because it would likely have too much bookkeeping overhead just in order to commit a small number
% % % % % % of transactions that otherwise would be aborted unnecessarily.
% % % % % % Specially we noticed that there were interesting ways that the ``not quite'' permissive algorithm of
% % % % % % figure \ref{fig:ttc-protocol} could be modified in order to make the read operations cheaper without impacting the correctness of
% % % % % % the algorithm that were not compatible with the permissive algorithm of figure \ref{fig:ttc-V22-protocol}.
% % % % % % 
% % % % % % 
% % % % % % %---------------------------------------------------------------------------
% % % % % % \subsection{Expediting  read operations}
% % % % % % 
% % % % % % Let us consider the invocations $X.{\sf read}_T()$ (those are issued by $T$).
% % % % % % From the second one, none of   these invocations access the shared memory. 
% % % % % % As  described in Figure \ref{fig:ttc-protocol}, the first invocation 
% % % % % % $X.{\sf read}_T()$ entails the execution of line \ref{BA10}
% % % % % %  whose costs is $O(|lrs_T|)$. 
% % % % % % %
% % % % % % Interestingly,  it is  possible  to define  ``favorable circumstances'' in
% % % % % % which the execution  of this line can be saved when  
% % % % % % $X.{\sf read}_T()$ is invoked for the  first time by $T$. Its  cost 
% % % % % % becomes  then  $O(1)$.   To that end, each 
% % % % % % process $p_i$ is required to manage  an additional local variable denoted 
% % % % % % $earliest\_read_T$ (that is initialized to $+\infty$ at line 
% % % % % % \ref{BA01} of Figure \ref{fig:ttc-protocol}). 
% % % % % % Line \ref{BA10} of  $X.{\sf read}_T()$  is then replaced by:
% % % % % % %
% % % % % % \begin{tabbing}
% % % % % % aaaaaaaa\=aaaa\=aaaaa\=aa\=\kill 
% % % % % % 
% % % % % % \> \> {\bf if} $(l$\=$cell(X).commit\_time >  earliest\_read_T)$\\
% % % % % % 
% % % % % % \> \> \> {\bf then} \=  Code of line \ref{BA10} %\\
% % % % % % 
% % % % % % %\> \> \> 
% % % % % % {\bf else} %\>  
% % % % % % $earliest\_read_T \leftarrow  lcell(X).commit\_time$ %\\
% % % % % % 
% % % % % % %\> \>  
% % % % % % {\bf end if}.\\  
% % % % % % 
% % % % % % \end{tabbing}
% % % % % % 
% % % % % % Hence, the protocol  allows for  {\it  fast}  read  operations in  favorable
% % % % % % circumstances. (It is even possible, at the price of another additional 
% % % % % % control variable, to refine the predicate used in the 
% % % % % % previous statement in order to increase the number of favorable cases.
% % % % % % Such an improvement is described in Appendix  \ref{appendix-fast-reads}. 
% % % % % % It is important to notice that, while these {\it  fast} read  operations
% % % % % % are possible when the consistency condition is VWC, they are not when it is
% % % % % % opacity.) 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % %===================================================
% % % % % % 
% % % % % % \subsection{More on fast read operations}
% % % % % % \label{appendix-fast-reads}
% % % % % % \paragraph{Virtual world consistency vs opacity}
% % % % % % Unlike opacity, a live transaction satisfying the VWC consistency criterion 
% % % % % % only has to be concerned with its causal past in order not to violate 
% % % % % % consistency.
% % % % % % When a new transaction commits in an opaque STM a live transaction has 
% % % % % % always to consider this transaction. In contrast  in a VWC STM, a live
% % % % % % transaction needs to consider only it if it is in the live transaction's 
% % % % % % causal past.
% % % % % % 
% % % % % % We can take advantage of this  observation  in order to increase 
% % % % % % the number of times a transaction performs fast reads.
% % % % % % This is not without a trade off though, allowing a transaction to only 
% % % % % % consider its causal past means that in certain cases transactions with 
% % % % % % no real time-compliant legal linear extension with previously committed 
% % % % % % transactions will have their abort operation delayed. 
% % % % % % Or in other words a transaction that is doomed to abort could possibly 
% % % % % % be allowed to stay alive longer.
% % % % % % In our STM we also have the cost of using an additional control variable.
% % % % % % How much efficiency is gained or lost by this will certainly depend on the 
% % % % % % execution.
% % % % % % 
% % % % % % 
% % % % % % The method described below is not the only way to take advantage of VWC 
% % % % % % for fast reads. It has to be seen as one  among several possible enhancements.
% % % % % % The idea is that when a live transaction $T$ reads a value written by 
% % % % % % some other transaction $T_1 \notin \mathit{past(T)}$,then $T_1$'s causal
% % % % % %  past is added to $\mathit{past(T)}$.
% % % % % % But if the commit time of the transaction in $\mathit{past(T_1)}$  with 
% % % % % % the largest  commit time is smaller then the commit time of all transactions 
% % % % % % that $T$ has read from then it is impossible for any of the transactions 
% % % % % % in $\mathit{past(T_1)}$ to overwrite any of $T$'s reads.
% % % % % % In this case only the transaction $T_1$ itself could overwrite a value 
% % % % % % read by $T$ causing $T$ to not be VWC, but this is only possible if $T_1$ 
% % % % % % has overwritten a value that was previously written by a transaction with 
% % % % % % commit time later then the commit time of the earliest transaction 
% % % % % % that $T$ has read from.  Thus using some extra control variables allows 
% % % % % % us to perform fast read operations in these cases.
% % % % % % 
% % % % % % 
% % % % % % 
% % % % % % \paragraph{An implementation}
% % % % % % This part discusses an implementation  of the previous idea. 
% % % % % % While a transaction is live it keeps a local variable called 
% % % % % % $latest\_read_T$ initialized as $commit\_time_i$ and updated 
% % % % % % during each $X.read_T()$ operation to the largest commit time of the 
% % % % % % transactions it has read from so far.
% % % % % % When $T$ executes line \ref{BA20} of the ${\sf try\_to\_commit}_T()$ 
% % % % % % operation, the variable $latest\_read_T$ 
% % % % % % is (possibly) increased  to the largest commit time of the 
% % % % % % transaction for the values $T$ is overwriting.
% % % % % % A boolean control variable, $overwrites\_latest\_read_T$ (initialized to
% % % % % % $\mathit{false}$) is set to $\mathit{true}$ if $latest\_read_T$ is 
% % % % % % modified.  To that end line\ref{BA20} is replaced by the code
% % % % % % described in Figure~\ref{fig:uwb-protocol}. 
% % % % % % 
% % % % % % 
% % % % % % %==================================================================
% % % % % % \begin{figure}[htb]
% % % % % % \centering{ \fbox{
% % % % % % \begin{minipage}[t]{150mm}
% % % % % % \footnotesize 
% % % % % % \renewcommand{\baselinestretch}{2.5} 
% % % % % % %\resetline
% % % % % % \begin{tabbing}
% % % % % % aaaaa\=aa\=aaaaa\=aa\=\kill ~\\
% % % % % % 
% % % % % % 
% % % % % % \line{BT57} \> {\bf for each} $(Y \in lws_T)$ {\bf do} \\
% % % % % % 
% % % % % % \line{BA58} \>\> $window\_bottom_T \leftarrow 
% % % % % %                \max((PT[Y]\downarrow).last\_read, window\_bottom_T)$;  \\
% % % % % % 
% % % % % % \line{BT59} \>\> {\bf if} ($(PT[Y]\downarrow).commit\_time 
% % % % % %                                       \geq latest\_read_T$) {\bf then} \\
% % % % % %                
% % % % % % \line{BT60} \>\>\> $latest\_read_T \gets (PT[Y]\downarrow).commit\_time$;
% % % % % % 		        	$overwrites\_latest\_read_T \gets true$ \\
% % % % % % 
% % % % % % \line{BT61} \>\> {\bf end if}  \\
% % % % % % 
% % % % % % \line{BT62} \>  {\bf end for}. \\
% % % % % % 
% % % % % % \end{tabbing}
% % % % % % \normalsize
% % % % % % \end{minipage}
% % % % % % }
% % % % % % \caption{Fast read: 
% % % % % % Code to replace line \ref{BA20} of  Figure~\ref{fig:ttc-protocol}}
% % % % % % \label{fig:uwb-protocol}
% % % % % % }
% % % % % % \end{figure}
% % % % % % %=================================================================
% % % % % % 
% % % % % % Moreover, when a transaction commits,  the values of $latest\_read_T$ and 
% % % % % % $overwrites\_latest\_read_T$ have now to be stored in shared memory along
% % % % % % with the other values in $CELL(X)$ for each variable $X$ written by  $T$.
% % % % % % 
% % % % % % Finally, line \ref{BA10} of  $X.{\sf read}_T()$  is replaced by  the 
% % % % % % following  statement:
% % % % % % 
% % % % % % \begin{tabbing}
% % % % % % aaaaaaaa\=aaaa\=aaaaa\=aa\=\kill 
% % % % % % 
% % % % % % (a) \> {\bf if}   
% % % % % %         \big(\= ($CELL(X).latest\_read > earliest\_read_T$)  $\vee$  \\
% % % % % % 
% % % % % % (b) \>  \>  ($CELL(X).latest\_read = earliest\_read_T$ 
% % % % % %              $\wedge$ $CELL(X).overwrites\_latest\_read$)\big)\\
% % % % % % 
% % % % % % \> \> $~$ $~$ $~$ {\bf then} Code of line \ref{BA10}  {\bf end if};\\  
% % % % % % 
% % % % % % \>  
% % % % % % $earliest\_read_T \leftarrow \min(lcell(X).commit\_time, earliest\_read_T)$;\\
% % % % % % 
% % % % % % \>  $latest\_read_T \leftarrow \max(lcell(X).commit\_time,latest\_read_T)$.\\
% % % % % % 
% % % % % % \end{tabbing}
% % % % % % 
% % % % % % 
% % % % % % \paragraph{Discussion}
% % % % % % It can be seen that there are two cases when 
% % % % % % ${\sf update\_window\_top}_T()$ will be required to be executed.
% % % % % % \begin{itemize}
% % % % % % \vspace{-0.2cm}
% % % % % % \item
% % % % % % The first corresponds to line (a), i.e., when the predicate 
% % % % % % $\mathit{CELL}(X).latest\_read > earliest\_read_T$ 
% % % % % % (let $T_1$ be the transaction that wrote $\mathit{CELL}(X)$) is satisfied, 
% % % % % % meaning  that there is 
% % % % % % at least one transaction in the causal past of $T$ that has a commit time 
% % % % % % earlier than either a transaction in the causal past of $T_1$, or a 
% % % % % % transaction that has written a value overwritten by $T_1$.
% % % % % % Thus a value read by $T$ might have been overwritten by $T_1$ or 
% % % % % % $past(T_1)$ and ${\sf update\_window\_top}_T()$ needs to be executed.
% % % % % % \vspace{-0.2cm}
% % % % % % \item
% % % % % % The second  corresponds to line (b), i.e., when the predicate 
% % % % % % $\mathit{CELL}(X).latest\_read = earliest\_read_T$ 
% % % % % % $\wedge$ $cell(X).overwrites\_latest\_read$ is true.
% % % % % % First, as  each transaction has a unique  commit time,  
% % % % % % when $\mathit{CELL}(X).latest\_read = earliest\_read_T$ then the transactions 
% % % % % % described by $\mathit{CELL}(X).latest\_read$ and $earliest\_read_T$ are 
% % % % % % actually the same transaction, call this transaction $T_2$.
% % % % % % So if the boolean variable $\mathit{CELL}(X).overwrites\_latest\_read$ is 
% % % % % % false, then $T_1$ just reads a value from $T_2$ resulting in there being no 
% % % % % % possibility of a read of $T$ being overwritten.
% % % % % % Otherwise if $\mathit{CELL}(X).overwrites\_latest\_read$ is 
% % % % % % satisfied,  then $T_1$ is overwritten a value written by $T_2$ and
% % % % % %  ${\sf update\_window\_top}_T()$ needs to be executed.
% % % % % % In all other cases a fast read is performed.
% % % % % % \end{itemize}
% % % % % % 
% % % % % % 
% % % % % % \paragraph{Fast read operations and opacity}
% % % % % % As mentioned previously performing fast reads in this way is only possible 
% % % % % % in VWC. We  give below a counterexample 
% % % % % % (Figure~\ref{fig:impossibility-fastreads-opacity}) in order to show that they 
% % % % % % are not  compatible with opacity. 
% % % % % % 
% % % % % % %---------------------------------------------------------------
% % % % % % \begin{figure}[ht]
% % % % % % \centering
% % % % % % \scalebox{0.35}{\input{VWC-comp/figures/fig-opac-impos-fastreads.pdf_t}}
% % % % % % \caption{Example of  fast reads that would violate opacity}
% % % % % % \label{fig:impossibility-fastreads-opacity}
% % % % % % \end{figure}
% % % % % % %---------------------------------------------------------------
% % % % % % 
% % % % % % In this figure we have $T_4$ committing first, then $T_2$ commits and must 
% % % % % % be serialized after $T_4$ because it reads the value of $X$ written by $T_4$. 
% % % % % % Next $T_3$ commits and must be serialized after $T_2$ because it overwrites 
% % % % % % the value of $Y$ read by $T_2$.
% % % % % % Finally we have $T_1$ which first reads the value of $X$ written by $T_4$ 
% % % % % % then reads the value of $Y$ written by $T_3$.
% % % % % % Now $T_1$ violates opacity because it must be serialized before $T_2$
% % % % % % ($T_2$ overwrites the value of $X$ it read) and after $T_3$ 
% % % % % % (it reads the value of $Y$ written by $T_3$), but we already know 
% % % % % % that $T_2$ is serialized before $T_3$.
% % % % % % On the other hand, $T_1$ is VWC because its causal past does not contain $T_2$.
% % % % % % Now we just need to show that ${\sf update\_window\_top}_T()$ is not executed 
% % % % % % during the execution of $Y.{\sf read}_{T_1}()$.
% % % % % % After    $T_1$    performs     $X.{\sf    read}_{T_1}()$    the    variable
% % % % % % $earliest\_read_{T_1}$  
% % % % % % is set to the commit time of $T_4$.
% % % % % % The value $latest\_read_{T_3}$ is the commit time of transaction $T_0$
% % % % % % so when $T_3$ commits we have $\mathit{CELL}((Y).latest\_read$ also set 
% % % % % % to this value. During $Y.{\sf read}_{T_1}()$ we have  
% % % % % % $\mathit{CELL}(Y).latest\_read < earliest\_read_{T_1}$ 
% % % % % % and ${\sf update\_window\_top}_{T_1}()$ is not executed. 
% % % % % % 
% % % % % % 
% % % % % % %=================================================================
% % % % % % \subsection{Making read operations invisible at commit time}
% % % % % % \label{appendix-invis-reads-at-commit}
% % % % % % 
% % % % % % \paragraph{Read invisibility vs  ${\sf try\_to\_commit}_T()$ invisibility}
% % % % % % Let  us observe  that read  invisibility requires that  
% % % % % % read operations be invisible  when they are issued by a transaction $T$, 
% % % % % % but  does  not  require they  remain  invisible  at  commit time. 
% % % % % % This  means that  the shared memory is not modified  during the  read
% % % % % % operation,  but a  ${\sf try\_to\_commit}_T()$ operation  is allowed to
% % % % % % modify   shared  memory locations  associated  with  base  objects read  by
% % % % % % transaction $T$. Interestingly though this does not always need to be the case.
% % % % % % 
% % % % % % Similarly to  fast read operations where line  \ref{BA10} 
% % % % % % of $X.{\sf read}_T()$ does not need  
% % % % % % to be always executed, a read does  not always need 
% % % % % % to  be made visible during the  ${\sf try\_to\_commit}_T()$ operation.  
% % % % % % There are two locations  in ${\sf try\_to\_commit}_T()$ 
% % % % % % that modify shared memory with respect to  objects $X\in lrs_T\setminus lws_T$. 
% % % % % % The first is on line \ref{BA31} where 
% % % % % % the value  of $cell(X).last\_read$ is updated for each object $X\in lrs_T$. 
% % % % % % The second is on line \ref{BA18} where each object $X\in lrs_T$ is locked.
% % % % % % Concerning efficiency and scalability, not  only can locking  and
% % % % % % writing  to shared  memory be  considered expensive  operations, but  is is
% % % % % % desirable for reads to be completely invisible. 
% % % % % % 
% % % % % % \paragraph{Discussion:  When  write to shared memory and lock can be avoided} 
% % % % % % Assume some shared variable $Y$ read by transaction $T$.
% % % % % % First consider the write to $cell(Y).last\_read$.
% % % % % % In the algorithm, the only time the $last\_read$ field of a cell is read
% % % % % % is on line \ref{BA20} of the ${\sf try\_to\_commit}_T()$ operation. 
% % % % % % Since $last\_read$ is only read  for objects in $lws_T$, 
% % % % % % and $T$ locks all objects in $lws_T$, $T$ is guaranteed to
% % % % % % be accessing the most recent cell. 
% % % % % % This means that, during a ${\sf try\_to\_commit}_T()$ operation on line 
% % % % % % \ref{BA31},  if  $lcell(Y).origin$ is  not the  latest cell  for $Y$,  
% % % % % % then the  value of $last\_read$ written will never be accessed and 
% % % % % % there is no reason to write the value. 
% % % % % % 
% % % % % % So the write on line \ref{BA31} is not necessary when $lcell(Y).origin$ is
% % % % % % not the latest cell,  what about the lock associated with $Y$? 
% % % % % % When is  it not necessary to lock  objects in $lrs_T$? 
% % % % % % This turns out to not be necessary in the same case.
% % % % % % If line \ref{BA31}  is not executed for some variable  $Y \in lrs_T$, then
% % % % % % the  only   other  place  a   cell  of  $Y$   is  accessed  in   the  
% % % % % % ${\sf try\_to\_commit}_T()$ operation is on line \ref{BA19}. 
% % % % % % Here the only shared memory accessed is $(lcell(Y).origin\downarrow).end$.
% % % % % % From  the construction  of the  algorithm $(lcell(Y).origin\downarrow).end$
% % % % % % will be  updated at most once, therefore  if the loop iteration for $Y$ on line \ref{BA10}
% % % % % % of ${\sf X.read}_T()$ (where $X$ and $Y$ may or may not be the same variable) had   been  executed    previously    with
% % % % % % $(lcell(Y).origin\downarrow).end \neq +\infty$ (meaning $(lcell(Y).origin\downarrow).end$
% % % % % % had been  updated previously), then  the loop iteration  for $Y$  does not need  to be
% % % % % % executed again which results in $Y$ not needing to be locked. 
% % % % % % 
% % % % % % \paragraph{An implementation} 
% % % % % % It follows from the previous discussion  that a read  operation of a shared variable 
% % % % % % $Y$ can be made invisible at commit time if $(lcell(Y).origin\downarrow).end$ had not equal to $+\infty$ 
% % % % % % during the loop iteration for $Y$ on line \ref{BA10} for any execution of ${\sf X.read}_T()$. 
% % % % % % Implementing this  in the  algorithm becomes easy, line
% % % % % % \ref{BA10} must be replaced by the following. 
% % % % % % \begin{tabbing}
% % % % % % aaaaaaaa\=aaaa\=aaaaa\=aa\=\kill 
% % % % % % 
% % % % % %  \> {\bf for each} $(Y \in lrs_T)$ {\bf do}\\
% % % % % %  
% % % % % %  
% % % % % % \>\> $window\_top_T \leftarrow 
% % % % % %           \min\big(window\_top_T,
% % % % % %      (lcell(Y).origin\downarrow).\mathit{end} \big)$; \\
% % % % % % 
% % % % % % \>\>  {\bf  if}  $((lcell(Y).origin\downarrow).\mathit{end} \neq  +\infty)$
% % % % % % {\bf then} $lrs_T \leftarrow lrs_T \backslash \{Y\}$  {\bf end if} \\
% % % % % % 
% % % % % % \> {\bf end for}. \\
% % % % % % 
% % % % % % \end{tabbing}
% % % % % % 
% % % % % % Using this  improvement there is  a possibility for a  transaction $T$ (that
% % % % % % performs  at least  one  read) to  have  some or  all of  its  reads to  be
% % % % % % invisible during the ${\sf try\_to\_commit}_T()$ operation. 
% % % % % % Consequently a  read  only  transaction  has  a
% % % % % % possibility to  be completely  invisible at commit  time, meaning  that the
% % % % % % ${\sf try\_to\_commit}_T()$ operation will just immediately return $commit$
% % % % % % without doing any work. 
% % % % % %  
% % % % % % \paragraph{Additional Benefits}  
% % % % % % It  is also  worth noting   that this  improvement  can  also   improve the
% % % % % % performance of  the read operations  performed by the STM. 
% % % % % % This is because when the one of  the new lines added is executed an object
% % % % % % is removed from $lrs_T$, and the  cost of the read operation depends on the
% % % % % % size of $lrs_T$. 
% % % % % % In the best case this can cause the cost of a read operation to be $O(1)$
% % % % % % instead  of $O(|lrs_T|)$  (note that   this works  concurrently  along with
% % % % % % fast reads as described  in Appendix \ref{appendix-fast-reads}). 






%===========================================================================
\section{Conclusion}
\label{sec:conclusion}

To conclude this chapter we will return to the idea that the main purpose of
transactional memory is to make concurrent programming easier.
Overall the contribution of this chapter is a study of the interaction
between several properties and consistency conditions of transactional memory.
So then, what does this have to do with the ease of use of 
transactional memory?

When designing an STM protocol it is necessary that we design it to satisfy
some consistency criterion.
This is important because these consistency criterion define the semantics
of a transaction to the programmer.
As long as the chosen consistency criterion is satisfied then we can start considering other
secondary, but still important things such as performance.
This is where different properties such as read invisibility and permissiveness
come in, a protocol that chooses or not to implement such properties might impact
the performance of that protocol, but does not change the semantics of a transaction.
By doing this we are putting the ease of use for the programmer as a first class requirement.
Furthermore this chapter suggests (following the trend of most STM research)
not using any consistency criterion for STM, but instead
using consistency criterion that ensures the atomicity
of transactions without allowing any transaction to execute in an invalid state of memory
thus keeping in our high level Definition \ref{def:trans-def}.
While this chapter only considers the part of this definition having to do with the
atomicity of transactions, later chapters consider other parts of the definition
in more detail.

The first contribution of this chapter shows that permissiveness and read invisibility are
incompatible with opacity, we then show that we can choose a weaker consistency criterion
(virtual world consistency) to design a protocol that satisfies permissiveness and
read invisibility.
Most importantly, even though we have weakened the consistency criterion, the programmer
will see no difference in the semantics of a transaction.
If virtual world consistency changed the way a programmer had to think about transactions versus opacity,
then it would not be considered an appropriate consistency criterion for transactional memory.

The second contribution of this chapter introduces a realistic algorithm that satisfies
virtual world consistency, permissiveness, and read invisibility.
% It then shows some ways to optimize the speed of the read operations of the protocol
% by trading-off some permissiveness.

An important position of this work is that instead of looking at properties independently,
it considers multiple properties at once.
More specifically it looks at the compatibility of properties, how realistic protocols can be
designed to satisfy them, and how trade-offs in these properties can be made for efficiency.
Hopefully these contributions promote the idea that studying such combinations is important for understanding
transactional memory and will also promote similar research on the many combinations
left unexamined.
Importantly this suggests that weakening the transactional model in the interest
of improving performance might not be necessary, as much of what is possible under the current
model has yet to be examined (actually further chapters will suggest even simplifying the model).
Recent research \cite{KR11} has suggested an interesting way to approach this problem by looking at the amount
of concurrency certain properties (or even combinations of these properties) might allow.
They do this by proving the minimum amount of expensive synchronization operations that are needed
by an STM in order to ensure these properties safely.

As a final note on ease of use, it should be said that the research direction suggested in
this chapter is also similar in a way to that of
the majority of published work on transactional memory in that it concerns itself with
designing an efficient protocol without modifying the idea of a transaction.
Each of the protocols presented in these various works (DSTM \cite{HLMS03}, TL2 \cite{DSS06}, TinySTM \cite{FFR08}, SwissSTM \cite{DGK09}, NOrec \cite{DSS10}, etc...) have no impact on how the programmer
understands the transaction which, in a way, puts ease of use first.
The following chapters will take a different direction, examining some of what we consider shortcomings
of the commonly used transactional model and how to improve it.

 
% This chapter has investigated the relation linking read invisibility, 
% permissiveness and two consistency conditions, namely, opacity and 
% virtual world consistency. 
% It has shown that  read invisibility, permissiveness and
% virtual world  consistency  are compatible. To that 
% end an appropriate  STM protocol has been designed and proved correct. 
%It has also been shown that this protocol allows for fast read
%operations while opacity does not. 



% \vspace{0.1cm}
% \paragraph{Acknowledgements}
% This research  is part of the TRANSFORM project, 
% a  Marie Curie project funded by the European Community's Seventh 
% Framework Programme  (grant agreement n 238639), devoted to the theory of 
% software transactional memories. 
% We also thank Hagit  Attiya  and Sandeep Hans for their constructive 
% comments on a draft of this paper. 
% %===========================================================================
% \newpage
% \section{Figures}



%=================================================================
% \end{document}
%=================================================================
%=================================================================