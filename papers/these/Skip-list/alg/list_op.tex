\begin{algorithm*}[!ht]
  \caption{List Specific Operations}\label{alg:list_op}% \vincent{Replace unit-read by read, then remove all tx read/write.}}
  \begin{algorithmic}[1]
   \begin{multicols}{3}
   {\size 
   		\Part{Additional fields of node $n$}{
			\State $\ms{node}$ a record with additional fields: 
			\State \T $\ms{next}$, pointer to the next node in the list
			\State \T $\ms{prev}$, pointer to the previous node in the list
   		}\EndPart
   	
%		\Statex   	
%		
%		\Part{State of shared memory $s$}{
%			\State $\ms{root}$ shared pointer to root 
%   		}\EndPart
		
		\Statex
		
		\Part{State of structure $s$}{
			\State $\ms{first}$, pointer to the first node in the list
			\State $\ms{next-trav}$, pointer to a node used for traversal in the maintenance
			%\State $\ms{curr}$, a pointer to a node used while traversing the tree
			%\State $\ms{\ell}, \ms{r}$, pointers to left/right children 
			%\State $\ms{lefth}, \ms{righth}, \ms{left-localh}, \ms{right-localh}, \ms{localh}  \in \mathbb{N}$
			%\State $\ms{bal} \in \mathbb{N}$, the imbalance level
		}\EndPart
		
		\newpage

   		\Part{$\act{get-first}()_s$}{

			\Return $\ms{first}$ \EndReturn
   		}\EndPart



		\Statex
   	
		\Part{$\act{get-next}(\ms{node}, \ms{k})_s$}{

			\If{$\ms{node.rem}$}
				\While{$\ms{node.rem}$}
					\State{$\ms{node} \gets \ms{node.prev}$}
				\EndWhile
			\Else{}
				\State $\ms{next} \gets \ms{node.next}$
				\If{$\ms{next = \bot} \cup \ms{next.k > k}$}
					\Return $\bot$ \EndReturn
				\Else{}
					\Return $\ms{next}$ \EndReturn
				\EndIf
			\EndIf
		}\EndPart

		\newpage

   		\Part{$\act{validate}(\ms{node}, \ms{k})_s$}{

			\If{$\ms{node.rem}$}
				\Return $\lit{false}$ \EndReturn
			\EndIf
			\If{$\ms{node.next = \bot} \cup \ms{node.next.key > k}$}
				\Return $\lit{true}$ \EndReturn
			\EndIf
			\Return $\lit{false}$ \EndReturn
   		}\EndPart
		
		\Statex

   		\Part{$\act{add}(\ms{node}, \ms{k})_s$}{

			\State \Comment{allocate a node called new}
			\State $\ms{new.key} \gets \ms{k}$
			\State $\ms{new.prev} \gets \ms{node}$
			\State $\ms{new.next} \gets \ms{node.next}$
			\State $\ms{node.next.prev} \gets \ms{new}$
			\State $\ms{node.next} \gets \ms{new}$
   		}\EndPart


		\Statex
   	

				


	}
    \end{multicols}
  \end{algorithmic}
\end{algorithm*}
