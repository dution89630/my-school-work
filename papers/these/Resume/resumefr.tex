
\chapter*{Resume}

Architectures multicœurs changent notre façon d'écrire des programmes.
Non seulement tous les dispositifs informatiques tournant multi devenant ainsi intrinsèquement parallèle,
mais demain multicœurs intégrera une plus grande quantité de cœurs simplifiés
afin de mieux gérer l'énergie tout en proposant des performances supérieures,
une technologie également connu sous le nom \emph{manycore}~\cite{Borkar2007} et donnant lieu à ce qu'on appelle
le \emph{multicœurs révolution} \cite{HL08}. Ainsi, afin de profiter de ces ressources, un renouveau de
la programmation concurrente a commencé.

Il s'agit d'un point de vue largement partagé que la conception d'un programme concurrent n'est pas une tâche facile.
Dans ce contexte, les objets de synchronisation de base ont été définis pour aider le programmeur à résoudre les problèmes de concurrence et de coopération processus.
Une étape importante dans ce domaine, qui a été présenté il y a plus de quarante ans, était le concept de {\it exclusion mutuelle} \cite{D68} qui a donné naissance à la notion de {\it lock} objet.
Un objet de verrouillage permet au programmeur de deux opérations (de verrouillage et de déverrouillage) qui permettent à un seul processus à la fois d'accéder à un objet concurrente.
Par conséquent, d'un point de vue objet concurrent, le verrou associé à un objet permet de transformer accès concurrents sur cet objet en accès séquentiels.
Le type de synchronisation admis par des verrous est souvent désigné comme \emph{pessimiste},
car chaque accès à un emplacement $x$ bloque des accès supplémentaires à $x$ jusqu'à ce que la emplacement soit libéré.
Il n'est pas surprenant donné que le processus de pensée d'une personne se passe de manière séquentielle et
que ce concept d'exclusion mutuelle est un moyen simple de concevoir de synchronisation/concurrence, le verrouillage est de
loin l'abstraction la plus largement utilisée pour mettre en œuvre des algorithmes concurrents.


Malheureusement, l'utilisation de verrous n'est pas si facile.
La difficulté la plus fréquente associée à verrouillage est d'éviter l'impasse.
L'impasse se produit par exemple lorsqu'un processus $T_A$ veut obtenir un verrou qui est déjà détenu par processus
$T_B$ tandis que le processus en même temps $T_B$ veut obtenir un verrou qui est déjà détenu par processus $T_A$ résultant dans aucun processus progresse.
Verrous de blocage afin d'éviter sont souvent acquises dans un ordre mondial,
mais cela peut entraîner des serrures prises plus souvent et plus longtemps tenue alors nécessaire.

D'autres problèmes avec verrous peut se produire quand un processus qui détient un verrou est dé prévue
par le système d'exploitation tout un processus vivant tente d'accéder à le même verrou (parfois appelé \emph{inversion de priorité}).
D'autres problèmes peuvent se produire si un thread se bloque ou est bloqué en tenant un verrou.

\paragraph{Mémoire software transactionnelle}
Le concept de \emph{mémoire software transactionnelle} (STM) est une réponse possible au défi de la programmation concurrente.
Avant de décrire les détails, d'abord envisager une ``philosophie esprit/design'' qui a contribué à donner naissance à des systèmes STM: la notion de \emph{niveau d'abstraction}.
Plus précisément, l'objectif d'un niveau d'abstraction accrue est de permettre au programmeur de se concentrer
et de se concentrer uniquement sur le problème qu'il doit résoudre et non sur la machine de base nécessaires pour le résoudre.
Comme nous pouvons le voir, c'est l'approche qui a remplacé les langages d'assemblage par des langages de haut niveau et collecte des ordures définié par le programmeur par collecte des ordures automatique.
Dans ce manière STM peut être considérée comme un concept nouveau niveau d'abstraction qui relève ce défi lors de l'examen des problèmes de synchronisation.


La façon dont la mémoire transactionnelle élimine la complexité associée à la programmation concurrente est de remplacer verrouillage avec unités d'exécution atomiques.
Contrairement à l'utilisation des verrous où un programmeur peut utiliser plusieurs verrous au long de ses opérations, lorsque il utilise la mémoire transactionnelle un programmeur n'a besoin que
de définir quelles sections de son code doit apparaître comme si elles exécuter de façon atomique (i.e. tout à la fois, ne laissant aucune possibilité pour des opérations simultanées entrelacés).
Le protocole de mémoire transactionnelle aborde ensuite la synchronisation nécessaire pour garantir que cela arrive.
Un programmeur pourrait penser que c'est comme en utilisant un seul verrou global où toutes les fois qu'il veut effectuer la synchronisation entre processus.
De cette façon, le programmeur doit se concentrer sur l'endroit où l'atomicité est nécessaire et non pas sur la façon dont il doit être rendu compte.
Le but d'un système STM est donc de décharger le programmeur de la gestion directe de la synchronisation qui est entraîné par des accès aux objets simultanés.


Plus explicitement, la STM offre au programmeur le concept {\it transaction} (ce concept est proche mais différente
de la notion de transactions rencontrées dans les systèmes de bases de données \cite{FFGH08, HCUAGSV07, HL08}).
Un processus est réalisé sous la forme (ou décomposée en) une séquence d'opérations,
chaque opération étant un morceau de code qui, lors de l'accès des objets concurrents, apparaît toujours comme s'il était exécuté de façon atomique.
C'est le travail du système STM pour garantir que les opérations sont exécutées comme
si elles étaient atomique en utilisant de faibles opérations de synchronisation de niveau comme compar\&swap ou même d'autres
abstractions telles que les verrous (notez que tous ces détails sont cachés par le programmateur
comme il ne a que accès à l'interface de la STM qui lui permet de définir des unités de calcul atomiques).


Un autre avantage important de l'utilisation mémoire transactionnelle sur les verrous est 
qu'un programme transactionnel peut être directement réutilisé par un autre programmeur dans son propre code.
Ainsi, un programmeur qui compose opérations à partir d'une bibliothèque d'opérations à une 
autre transaction est garantie d'obtenir de nouvelles opérations sans impase qui sont exécutées de manière atomique.
Promouvoir davantage la facilité d'utilisation de transactions, plusieurs études \cite{PA11, RHW10} ont été réalisées qui
trouvent que (selon les paramètres de leurs études) les utilisateurs peuvent créer des programmes concurrents plus facile 
lorsque ils utilisent la mémoire transactionnelle au lieu de verrous.


La notion de mémoire transactionnelle a été proposée il ya près de vingt ans par Herlihy et Moss comme une abstraction à mettre
en œuvre en hardware et être utilisé afin de mettre en œuvre facilement des structures de données concurrentes sans-verrou \cite{HM93}.
Depuis, il a d'abord été mis en œuvre dans le logiciel par Shavit et Touitou \cite{ST97} et, en partie grâce à la
révolution multi-core, a récemment pris de l'ampleur grand comme une alternative prometteuse aux verrous dans la programmation concurrente \cite{FFGH08,HCUAGSV07,LK08,R08}.


Comme une abstraction conçu pour rendre plus facile la programmation concurrente, la mémoire transactionnelle a
besoin d'une interface simple et précis pour les programmeurs à utiliser.
Afin de effectivement définir des transactions dans le code,
l'approche la plus courante consiste à entourer le code par quelques mots-clés qui indiquent le début et la fin d'une transaction.
Par exemple, le programmeur peut simplement entourer sa transaction en utilisant le \emph{atomique} mot-clé.
Le code contenu dans ce bloc sera alors traitée comme une transaction et semblent être exécutés de façon atomique.
Dans un monde idéal, ce serait tout que le programmeur aurait à connaître avant de commencer à utiliser la mémoire transactionnelle,
mais malheureusement, comme on le verra dans cette thèse, il est beaucoup plus complexe que cela et il ya beaucoup d'autres choses que le programmeur doit prendre en considération.



Comme nous le verrons dans chaque chapitre de cette thèse dans un système moderne concurrentes
il ya des aspects complexes de l'abstraction STM qui concernent comment un programmeur interagit avec le système STM et le système dans son ensemble.
Alors que la sémantique de base d'une transaction sont largement convenu (i.e. atomicité de la transaction par rapport à d'autres transactions),
il ya beaucoup d'autres détails à prendre en considération certains d'entre eux sont activement débattus et restent sous forme de questions de recherche ouverts.
La normalisation de ce sémantique et à répondre aux questions ouvertes sur il est une étape importante pour garantir
que l'objectif principal de rendre plus facile la programmation concurrente est réalisée.
Si la sémantique est trop difficile à comprendre, ou un programmeur doit être conscient de trop de détails spécifiques à un système
STM avant de pouvoir utiliser les transactions dans son programme, puis la vue de l'objectif original a été perdu.



L'objectif de cette thèse est de faire un pas vers la retrouvailles et la définition fixe et facile à
comprendre de la sémantique des transactions tout en trouvant des protocoles efficaces satisfaisant à cette sémantique.



Chaque chapitre de cette thèse considère un domaine générale différent de la recherche autour du concept de la facilité
(ou la difficulté) de la programmation concurrente en utilisant la mémoire transactionnelle, introduisant d'abord le domaine du lecteur,
suivie d'une discussion d'un problème spécifique et une solution possible à partir de la région, chacun aidant à aller vers une solution de notre objectif.



\section{Chapitre 1}

L'objectif le plus important de l'abstraction STM est de rendre la programmation concurrente plus simple et plus accessible à tout programmeur.
On peut dire alors tout ce qu'un programmeur doit besoin de savoir afin d'utiliser l'abstraction STM est
de connaître la syntaxe pour écrire un bloc atomique, probablement quelque chose d'aussi simple que $atomique\{ \dots \}$.
Au niveau le plus élémentaire tout un programmeur devrait besoin de savoir est par où commencer et finir ses blocs atomiques.

Comme de nombreuses abstractions, même si ce qui est exposé au programmeur est une interface fixe bien défini,
il ya beaucoup de différentes implémentations possibles et des propriétés différentes qui existent pour fournir l'abstraction.
Sous ces blocs atomiques est la mise en œuvre de la STM, qui comporte de nombreux aspects.
Depuis l'introduction de mémoire transactionnelle en 1993 \cite{HM93} des dizaines (voire des centaines) de propriétés différentes
sont apparues ainsi que de nombreux algorithmes STM différentes, chacune d'entre elles en guarantissant plus ou moins de ces propriétés et être plus ou moins concernés par la performance.
(Certaines de ces propriétés sont discutées dans l'introduction de cette thèse dans la section \ref{sec:details})


Peut-être le plus important de ces propriétés concernent la exactitude de l'algorithme.
Souvent désigné comme les critères de cohérence de STM, ils guarantissant que le protocole mise en œuvre l'abstraction correctement.
En faisant cela, la facilité d'utilisation est prise d'une importance capitale,
permettant aux utilisateurs de ne pas avoir à s'inquiéter de comportement étrange qui ferait l'abstraction plus difficile à comprendre.
Dans le critère de cohérence STM sont utilisés afin d'guarantir que les transactions seulement observer états
valides de mémoire (i.e. états créés par seulement les transactions atomiques).
En raison de la nature optimiste et en ligne des transactions, les lectures et les écriture d'une transaction pourrait entrer en conflit
avec une transaction concurrente , c'est à dire si elles étaient tous les deux continuer à s'exécuter, l'un d'entre eux serait observer un état non valide de la mémoire.
Les critères de cohérence de STM STM éviter cela, et afin de le faire le protocole STM annulerait l'une des transactions, ce qui signifie qu'il semble avoir pas exécuté du tout.
La transaction peut alors être redémarré.
Ce chapitre se penche sur la façon dont ces critères de cohérence, qui guarantissant un niveau fondamental de facilité d'utilisation pour STM,
se rapportent à d'autres propriétés qui concernent les choses moins importantes comme la performance.


Dans un monde idéal, il existerait un \emph{``parfaite algorithme''} STM qui garantit toutes les propriétés désirables sans faire de sacrifices.
Malheureusement, cet algorithme n'a pas encore été découverts (si c'est encore possible).
En fait, beaucoup de ces propriétés désirables ont été un peu plus alors introduit et plusieurs de leurs implications sur la façon
dont ils affectent algorithmes STM ou comment ils interagissent les uns avec les autres n'a pas encore été exploré.
Motivé par cela, ce chapitre examine deux propriétés désirables qui se préoccupent de la performance,
à savoir \emph{permissivité} et \emph{lectures-invisible}, et comment ils interagissent avec deux critères de cohérence des systèmes STM,
à savoir \emph{l'opacité} et le \emph{consistance monde virtuel}.



\paragraph{Opération de lecture invisible}
Une opération de lecture émis par une transaction est {\it invisible}
si elle n'implique pas la modification des objets partagés utilisés pour mettre en œuvre le système STM \cite{MSHAESS06}.
Il s'agit d'une propriété désirable principalement pour l'efficacité.


\paragraph{Permissivité}
La notion de permissivité a été introduite dans \cite{GHS08} (dans un certain sens,
il s'agit d'une généralisation très agréable de la notion de {\it obligation} propriété \cite{a-IR09}). C'est sur la annulation de transaction.
Intuitivement, un système STM est {\it permissive} ``si elle n'a jamais annule une transaction sauf si c'est nécessaire pour l'exactitude.''
(sinon, il est {\it non-permissive}). Plus précisément, un système STM est permissive par rapport à une condition de cohérence
(par exemple, l'opacité) si elle accepte toute histoire qui satisfait la condition.

Comme indiqué dans \cite{GHS08}, un système STM qui vérifie lors du commit que les
valeurs des objets lus par une transaction n'ont pas été modifiées (et annule la transaction si vrai) ne peut pas être permissive par rapport à l'opacité.
En fait autre que le protocole introduit avec la notation de permissivité dans \cite{GHS08} pratiquement
tous les protocoles STM publiés annuler les transactions qui auraient pu être commises sans risque, à savoir les protocoles ne sont pas permissives.


\paragraph{Deux conditions de cohérence pour les systèmes STM}
Nous avons déjà notre syntaxe définie pour le programmeur ($atomique \{ \dots \})$) et d'une idée fondamentale de ce que cela signifie,
``le code dans le bloc atomique apparaît comme si elle a été exécutée instantanément par rapport à autres opérations'',
mais nous avons besoin de définir précisément ce que cela signifie pour un algorithme STM.
Au cœur de ce que nous avons critères de cohérence.
Ce critère de définir précisément la sémantique d'une transaction et guider la création d'algorithmes afin que le critère choisi est satisfaite.
Sans un critère de cohérence claire et précise nous perdons la facilité d'utilisation qui est l'intention originale de la STM.
Dans cette section, nous donnons un aperçu de deux critères de cohérence bien connu définis pour la mémoire transactionnelle.



\paragraph {La condition de cohérence opacité}
Le critère de cohérence classique pour les transactions de base de données est sérialisation \cite{P79}, approximativement définie comme suit:
``Une histoire est sérialisable si elle est équivalente à celle dans laquelle les transactions apparaissent à exécuter de manière séquentielle, c'est à dire, sans entrelaçage.''
Ce qui est important à considérer lorsqu'on pense à la mémoire transactionnelle est que le critère de cohérence sérialisation ne concerne que les transactions qui commettent.
Dit autrement, une transaction qui est annulée n'est pas empêchés d'accéder à un état incohérent avant d'annuler.
Il convient de noter que la sérialisabilité est parfois renforcée dans ``serializability stricte''.
La sérialisabilité stricte a la contrainte supplémentaire que l'histoire séquentielle équivalente doit suivre l'ordre de temps réel
de sorte que chaque transaction est placée quelque part entre son invocation et son temps de réponse, comme mis en œuvre par de l'utilisation du mécanisme de verrouillage en 2 phases.
La sérialisabilité stricte est souvent désigné comme linéarisabilité \cite{HW90} lorsque l'on considère les opérations d'un objet au lieu du système entirer.


Si les transactions ne sont pas annulée avant d'observer un état incohérent de la mémoire,
puis des comportements indésirables telles qu'exceptions de division par zéro peuvent se produire
(un exemple d'exécution dans lequel telle exception se produit est décrit dans la section \ref{sec:int-correct} de l'introduction).
Encore pire des comportements indésirables peuvent être obtenus lors de la lecture des valeurs des états incohérents.
Cela se produit par exemple quand un état incohérent fournit une transaction avec les valeurs qui génèrent des boucles infinies.
Ces mauvais comportements doivent être évités dans les systèmes STM:
quel que soit son sort (validation ou annulée) une transaction doit toujours voir un état cohérent de la mémoire consultée.
Les transactions annulées doivent être inoffensifs.




Informellement suggéré dans \cite{DSS06}, et officiellement présenté et étudié dans \cite{GK08},
la {\it opacité} condition de cohérence exige qu'aucune transaction, à tout moment, lit les valeurs d'un état global incohérent où,
en ne considérant que l'transactions validées, un {\it cohérente global état} est définie comme l'état de la mémoire partagée à un instant de temps réel.





\paragraph{Cohérence des mondes virtuels}
Cette condition de cohérence, introduit dans \cite{IR09}, est plus faible que l'opacité tout en gardant son esprit.
Il déclare que (1) aucune transaction (validée ou annulée) lit les valeurs d'un état global incohérent,
(2) les états globaux cohérents lus par les transactions validées sont cohérents entre eux (dans le sens où ils peuvent être totalement ordonné),
mais (3), tandis que l'état global lu par chaque transaction annulée est compatible à partir de son point de vue individuel,
les états globaux lus par deux transactions annulée sont pas tenus d'être cohérents entre eux.

En plus du fait qu'il peut permettre à davantage de transactions à commettre d'opacité,
l'un des points les plus importants de la cohérence monde virtuel réside dans le fait que, comme l'opacité,
il empêche les phénomènes mauvaises (comme décrit précédemment) de se produire sans nécessiter de tous les transactions
(validée ou annulée) se mettre d'accord sur là même exécution témoin.
Supposons que chaque transaction se comporte correctement (par exemple, il n'implique pas une division par 0,
il ne pas entrer dans une boucle infinie, etc) lorsque, exécuté seul, il lit les valeurs d'un état global cohérent.
Comme, grâce à la condition de consistance monde virtuel, aucune transaction (validée ou annulée) lit un état incohérent,
il ne peut pas comporter de manière incorrecte malgré la concurrence, il ne peut que être interrompue.
Cette condition de cohérence peuvent bénéficier des applications STM nombreux que, de son point de vue local,
une transaction ne peut le différencier de l'opacité.




Alors qu'est-ce que cela signifie pour le programmeur qui prévoit d'utiliser la mémoire transactionnelle pour écrire son programme concurrent?
Implications sur les performances possibles de côté, absolument rien, le programmateur
ne vois aucune différence entre un protocole STM qui est opaque par rapport à celui qui est le monde virtuel cohérent.
Compte tenu de l'exigence première de la mémoire transactionnelle est la facilité d'utilisation, cela est extrêmement important,
la cohérence monde virtuel serait beaucoup moins intéressant comme condition de cohérence si cela n'était pas vrai.

La première contribution de ce chapitre montre que l'invisibilité des lectures et la permissivité sont incompatibles avec l'opacité,
puis nous montrons que nous pouvons choisir un critère plus faible cohérence (consistance monde virtuel) de concevoir un protocole qui satisfait la permissivité et l'invisibilité des lectures.
Plus important encore, même si nous avons affaibli le critère de cohérence, le programmeur ne verra aucune différence dans la sémantique d'une transaction.
Si la cohérence monde virtuel a changé la façon dont un programmeur devait penser aux transactions par rapport à l'opacité,
puis il ne serait pas considéré comme un critère de cohérence approprié pour la mémoire transactionnelle.


La deuxième contribution de ce chapitre présente un algorithme réaliste qui satisfait la cohérence monde virtuel, la permissivité, et l'invisibilité des lectures.

Globalement, la contribution de ce chapitre est une étude de l'interaction entre plusieurs propriétés et les conditions de cohérence de mémoire transactionnelle.
Alors, qu'est-ce que cela a à voir avec la facilité d'utilisation de la mémoire transactionnelle?




Lors de la conception d'un protocole STM, il est nécessaire que nous le concevons pour satisfaire un critère de cohérence.
Ceci est important parce que ce critère de cohérence définit la sémantique de un transaction pour le programmeur.
Tant que le critère de cohérence choisi est satisfaite, alors nous pouvons commencer à envisager d'autres secondaires,
mais important, choses telles que la performance.
C'est là que des propriétés différentes comme l'invisibilité et la permissivité lire entrer,
un protocole qui choisit ou pas de mettre en œuvre telles propriétés pourraient affecter le performance de ce protocole, mais ne modifie pas la sémantique d'une transaction.
En faisant cela, nous mettons la facilité d'utilisation pour le programmeur comme une exigence de première classe.
En outre, ce chapitre suggère (suivant la tendance de la plupart de recherche STM) en n'utilisant pas n'importe quel critère de cohérence pour STM,
mais plutôt de choisir critère de cohérence qui garantit l'atomicité des transactions sans permettre à toute opération à exécuter dans un état non valide de la mémoire.




\section{Chapitre 2}

Opacité et autres critère de cohérence sont parfois également appelées propriétés de sécurité.
Informellement c'est parce qu'ils guarantissant un protocole qui eux implémente va
agir de manière à ce qu'un utilisateur pourrait s'attendre et ne pas produire aucun comportement bizarre.
Par exemple, comme mentionné précédemment, l'opacité empêche les transactions de s'exécuter sur les états invalides de la mémoire, empêchant
des choses telles que des exceptions de diviser par zéro dans le code correct.
Même si les autres critère de cohérence supprimer la complexité d'avoir à traiter avec des états non définis de la mémoire,
ils laissent ouvertes d'autres problèmes pour le programmeur faire face aux ce que pourrait rendre l'utilisation de STM plus difficile.
En ce sens, nous proposons de cacher certains de ces problèmes au programmeur en traitant avec eux dans la mise en œuvre de la STM.




Remarquez comment dans le chapitre précédent aucune mention n'est faite de la façon dont comment fréquemment les transactions sont validées, en particulier, le critère de cohérence ne font aucune considérations à ce sujet.
Par exemple, un protocole pourrait satisfaire l'opacité par tout simplement faire annuler toute transaction avant qu'elle n'ait effectué aucune action, mais bien sûr, ce protocole serait inutile.
Afin d'éviter cela, certains protocoles STM satisfaire liveness (ou progrès) propriétés.
Ces propriétés (dont certains ne se limite pas à la mémoire transactionnelle) guarantissant que les opérations d'un processus fera une sorte de progrès, parfois en fonction du nombre de conflits dans le système.






Malheureusement, le programmeur doit toujours comprendre le concept de abort / commit comme un complexité qui
est présumé quand il décide d'utiliser la mémoire transactionnelle dû au fait que les protocoles STM actuelles ne garantissent pas qu'une transaction commettre.
Dans certains cas, le programmeur doit traiter directement avec les transactions annulées dans son code,
dans d'autres, un programmeur peut prioriser certaines transactions afin qu'elles ne pas avorter, dans d'autres cas le protocole permet aux transactions d'être bloqués,
tandis que d'autres, les transactions peuvent être annulée à l'infini.
Absent à partir de ces solutions est le cas où toutes les transactions sont garanties à commettre où les
progrès d'une transaction ne repose pas sur les autres processus à l'exception de celui qui a émis la transaction.
Telle solution donnerait la priorité à la facilité d'utilisation tant que ce type de protocole se cacherait le concept d'opérations annulée du programmeur lorsque l'on considère l'progrès du système.



Semblable à une construction universelle sans-attente, le protocole garantit une progression en utilisant le concept de processus d'aide.
Un processus qui émet une transaction qui est annulée demanderont que d'autres processus aider en essayant simultanément d'exécuter l'opération, veiller à ce que finalement la transaction sera commise.
Une difficulté qui se pose de ce type d'aider qui est résolu par cet algorithme est garantir que la transaction n'est pas commis plus d'une fois.



Chapitre 1 a exploré un domaine de recherche de la mémoire transactionnelle qui se concentre sur
l'amélioration des protocoles STM sans affecter la façon dont l'utilisateur interagit avec la STM,
que est garantir la mise en œuvre des propriétés ou par l'augmentation de le performance.
Ce chapitre, bien que similaire au chapitre précédent en suggérant des propriétés et en montrant comment un protocole peut les mettre en œuvre,
adopte une approche plus visible qui a des répercussions directes sur l'interaction entre le programmateur et la STM.
Abstraitement, il examine comment la sémantique est définie entre le programmateur et le protocole STM et suggère qu'ils soient simplifiées.
En supprimant la notion d'transactions annulée de la sémantique et de garantir que chaque transaction commettre,
quel que soit le motif de l'exécution des autres processus dans le système, nous nous dirigeons vers un système plus facile à utiliser.


Des recherches antérieures ont prévu un certain niveau d'interaction entre le programmateur et les transactions annulées,
tandis que ce chapitre suggère la notion de commit/annuler être complètement abstraite en dehors de niveau programmeur laissé à être uniquement une préoccupation mise en œuvre.
Cela libère le programmeur d'avoir à se demander si sa transaction pourrait ne pas commettre et soit tenter d'éviter une telle situation, ou pour trouver des moyens d'y faire face quand il le fait.


\section{Chapitre 3}

Une sémantique transactionnelle simplifiées peuvent ne pas être suffisant, ce chapitre suggère l'expansion de la sémantique.
Il examine comment un programmeur peut utiliser des transactions au sein de son code dans un système plus large afin de proposer
l'extension de la sémantique transactionnelle dans l'intérêt de la facilité d'utilisation.


Ce chapitre est d'avis que les opérations exister en tant que partie intégrante d'un programme de le utilisateur.
Le programmeur met ensuite un groupe de lecture et d'écriture dans un bloc de code délimitée par les mots-clés
$\act{transaction\_begin}()$ et $\act{transaction\_end}()$ (ou bien le bloc atomique $\act{atomique}\{ \dots \} $).
Cette opération atomique existe directement comme un morceau de son code, précédé et suivi par le code, également écrit par le programmeur.
Dans ce bloc de code les lectures et écritures de la mémoire partagée sont ensuite traités par le protocole comes lectures et écritures transactionnel,
tout en les lectures et écritures simples effectuées dans le code en dehors des transactions sont non-transactionnels.


A ce stade, nous avons un choix important à faire face à la sémantique et l'exactitude d'une transaction lorsque l'on considère la mémoire partagée.
Est-ce que les transactions devrait semblent être atomiques que lorsque l'on considère d'autres transactions, ou devrait les accès concurrente non-transactionnel de la mémoire partagée également être pris en compte?
Plus précisément, si la mémoire partagée qui est accessible à partir de l'intérieur d'une transaction en
toute sécurité être seulement accessible à partir de transactions, ou doit-il être sûr d'accéder à la mémoire à l'intérieur et à l'extérieur de transactions à tout moment?


Si, dans un programme, il existe deux sets de de la mémoire partagée, un set pour accéder à l'intérieur des transactions,
et un autre pour accéder à l'extérieur de transactions, alors nous perdons la notion d'transactions faisant partie
intégrante du programme de le utilisateur pour plus d'un concept où transactions Il existe comme un objet distinct isolé.
Dans le second cas, les transactions pourraient représenter une interface de programmation définie pour un grand objet partagé et distincte du reste du système.
Les transactions sont toujours définis et placés par le programmeur, mais ils sont limités à la mémoire qu'ils peuvent accéder.
D'autre part, si le programmeur peut accéder à la mémoire partagée à la fois à l'intérieur et à l'extérieur des transactions
tout en guarantissant l'atomicité de ces transactions, alors le système devient plus simple.
Malheureusement, pour guarantir cela n'est pas clair et c'est le problème abordé par le présent chapitre.



\paragraph{Isolement forte}

Le \emph{isolement forte} garantit que tant les opérations de lecture et d'écriture transactionnel et non-transactionnel sont mises en œuvre d'une manière qui prend leur co-existence en compte.
Plus précisément, l'isolement forte garantit que les accès non-transactionnelles à mémoire partagée ne violent pas l'atomicité des transactions.



Afin de mieux comprendre les garanties de l'isolement forte, considérons une extension simple et intuitive qui peut être appliquée à un protocole STM afin d'garantir l'isolation forte.
Afin de fournir cette extension, toute opération non transactionnel qui accède à des données partagées est simplement considéré comme un ``mini-transaction'', c'est à dire, une transaction qui contient une seule opération lecture/écriture.
Dans ce casles transactions devront être conformes non seulement par rapport à d'autres transactions, mais aussi par rapport à les opérations non transactionnelles.
Évidemment, dans cette solution il n'ya pas de section distincte de la mémoire pour les transactions et leur atomicité est préservée, ce qui entraîne un cadre plus simple pour le programmeur.


\paragraph{Isolement forte terminant}

Considérons maintenant une solution au problème d'garantir la isolation forte en utilisant les mécanismes typiques de verrous ou barrières:
Chaque variable partagée serait alors associée avec un verrou et les deux types de opérations (transactionnelles et non-transactionnelles) devront accéder à le verrou avant d'accéder à la variable.
Les verrous sont déjà utilisées dans les algorithmes STM - comme TL2 \cite{DSS06} - où il est toutefois supposé que la mémoire partagée est uniquement accessible par les transactions.
L'utilisation de verrous dans un algorithme STM implique le blocage et peut même conduire à la famine de les processus.
Des recherches antérieures sur les protocoles STM a adopté l'approche que ces caractéristiques peuvent être acceptables.
Maintenant, si nous avons des opérations non transactionnelles qui s'appuient sur ​​les mêmes mécanismes (soit mis en œuvre utilisant de verrous ou par mini-transactions),
ils sont également susceptibles à la possibilité même de la non-exécution.


Toutefois, normalement le concept d'un lecture/écriture de memoire partagé n'inclut pas cette possibilité.
Lorsqu'il s'agit d'un single lecture ou en écriture sur une variable partagée, une opération non transactionnelle est normalement comprise comme un événement qui se produit de façon atomique et termine toujours.
Lors de l'exécution, une lecture ou d'écriture ne devrait pas être dé-prévu, bloqué ou interrompu.
Malheureusement forte isolation mis en œuvre avec des verrous implique le blocage des opérations de lecture et d'écriture non transactionnelles et ne fournit pas le terminaison.



Pour cette raison, nous croyons que la mise en œuvre d'un protocole fort isolement devrait également examiner le progrès des opérations non transactionnelles.
Afin de faire face à cela, nous suggérons qu'un protocole STM devrait mettre en place \emph{l'isolement forte terminant},
que nous définissons simplement que l'isolement fort avec la garantie supplémentaire que les opérations de lecture et d'écriture non-transactionnelles d'un processus sont garantis à terminer,
peu importe les actions de processus concurrents dans le système.


Ce chapitre présente un algorithme qui permet d'atteindre ``fort isolement terminant'' sur le dessus d'une algorithme STM basé sur les dates logiques et verrous, nommément TL2.
Dans le cas d'un conflit entre une transaction et une opération non-transactionnelle, cet algorithme donne la priorité à l'opération non-transactionnel,
avec le raisonnement que même si un annulation ou redémarrage éventuel est s'inscrite dans la spécification d'une transaction, ce n'est pas le cas d'une single lecture ou d'écriture de memoire partagée.
Ceci permet au programmeur de connaître son transaction exécutera de façon atomique, même en présence de l'accès mémoire non-transactionnelle,
tout en garantissant l'accès non-transactionnel ne sont jamais bloqués de progresser.



L'interaction entre les accès transactionnelles et non transactionnelles à mémoire partagée n'est qu'un parmi de nombreuses interactions possibles qu'un programmeur peut faire face quand il utilise des transactions.
Par exemple, il pourrait vouloir utiliser des verrous ou des opérations atomiques de hardware en même temps que les transactions, ou il pourrait vouloir utiliser des I/O au sein de ses transactions.
Chacun de ces derniers et beaucoup d'autres choses méritent une enquête sur les modèles possibles où elles sont considérées aux côtés de la sémantique des transactions.
De futures recherches sont nécessaires pour déterminer comment ces opérations supplémentaires peuvent être ajoutés à l'écosystème STM d'une manière qui n'entrave pas la facilité d'utilisation.

